\chapter{Implementacja zagadek}
\label{chap:development}

\section{Zadanie 1 – wzory skróconego mnożenia (Andrii Demyshyn)}
W tym zadaniu zrealizowano zagadkę poświęconą wzorom skróconego mnożenia. 
Zadaniem gracza jest prawidłowe połączenie początków i końcówek wzorów skróconego mnożenia poprzez umieszczenie odpowiednich klocków w przeznaczonych dla nich miejscach.

Kiedy gracz pojawia się w pokoju, widzi przed sobą tablicę z początkami wzorów skróconego mnożenia do uzupełnienia, a także klocki z różnymi formułami, panel informacyjny oraz przycisk do sprawdzenia odpowiedzi.

\subsection{Opis obiektów pokoju}

\subsubsection{Matematyczna tablica \texttt{BP\_MathBoard}}

Głównym obiektem pokoju jest matematyczna tablica zrealizowana w postaci blueprintu aktora \texttt{BP\_MathBoard}. 
Tablica zawiera siedem wzorów do uzupełnienia:

\begin{enumerate}
    \item \textbf{Kwadrat sumy}  
    \[
    (a+b)^2 = a^2 + 2ab + b^2
    \]

    \item \textbf{Kwadrat różnicy}  
    \[
    (a-b)^2 = a^2 - 2ab + b^2
    \]

    \item \textbf{Różnica kwadratów}  
    \[
    (a-b)(a+b) = a^2 - b^2
    \]

    \item \textbf{Sześcian sumy}  
    \[
    (a+b)^3 = a^3 + 3a^2b + 3ab^2 + b^3
    \]

    \item \textbf{Sześcian różnicy}  
    \[
    (a-b)^3 = a^3 - 3a^2b + 3ab^2 - b^3
    \]

    \item \textbf{Rozkład sumy sześcianów}  
    \[
    a^3 + b^3 = (a+b)(a^2 - ab + b^2)
    \]

    \item \textbf{Rozkład różnicy sześcianów}  
    \[
    a^3 - b^3 = (a-b)(a^2 + ab + b^2)
    \]
\end{enumerate}

Naprzeciw każdego wzoru, po znaku „=”, znajduje się odpowiedni slot, do którego należy umieścić końcówkę wzoru. 
Każdy slot składa się z następujących elementów:

\begin{itemize}
    \item wyróżnionego kolorem obszaru,
    \item komponentu \texttt{Box Collision},
    \item komponentu \texttt{Scene Component -- Point},
    \item oczekiwanego identyfikatora \texttt{ExpectedID},
    \item zmiennej typu bool \texttt{Slot[i]IsNoFull}, która informuje, czy slot jest zajęty (domyślnie ustawiona na \texttt{True}),
    \item własnego materiału slotu \texttt{Slot[i]HighLightMaterial}.
\end{itemize}

Każdemu slotowi odpowiada tylko jeden poprawny obiekt z formułą.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/tablica.png}
    \caption{Wygląd BP\_MathBoard}
    \label{fig:Lamp}
\end{figure}
\subsection{Zakończenie zadania}
\subsection{Zakończenie zadania}
W obiekcie \texttt{BP\_MathBoard} zaimplementowano również funkcję \texttt{AreAllSlotsFilled}, która sprawdza, czy wszystkie sloty zostały uzupełnione oraz czy zostały uzupełnione poprawnie.

\subsubsection{Prostopadłościan z formułą \texttt{BP\_FormulaBlock}}

Wszystkie formuły są przedstawione jako interaktywne obiekty 3D w postaci \texttt{BP\_FormulaBlock} typu Blueprint Actor. 
Gracz może podnosić i przenosić te obiekty po pokoju oraz umieszczać je w slotach tablicy.

Każdy obiekt \texttt{BP\_FormulaBlock} składa się z:
\begin{itemize}
    \item komponentu \texttt{StaticMesh},
    \item komponentu \texttt{TextRender} z odpowiednią formułą,
    \item komponentu \texttt{Box Collision},
    \item identyfikatora \texttt{FormulaID}.
\end{itemize}

Występują zarówno poprawne obiekty \texttt{BP\_FormulaBlock}, zawierające prawidłowe końcówki wzorów, jak i obiekty fałszywe (fikcyjne). 
Obiekty fałszywe wizualnie nie różnią się od poprawnych, lecz zawierają formuły oraz identyfikatory \texttt{FormulaID}, które nie pasują do żadnego wzoru. 
Zostały one dodane w celu zwiększenia poziomu trudności oraz zmylenia gracza. 
Formuły te są niemal poprawne, jednak zawierają drobne błędy, takie jak niewłaściwe znaki, współczynniki lub mieszanie typów wzorów.

\subsubsection{Przycisk sprawdzenia \texttt{BP\_CheckMath}}

Na poziomie zaprojektowano przycisk \texttt{BP\_CheckMath}, który umożliwia sprawdzenie poprawności uzupełnienia tablicy \texttt{BP\_MathBoard}. 
Gracz decyduje, kiedy chce sprawdzić rozwiązanie, a po kliknięciu przycisku aktywowana jest funkcja \texttt{AreAllSlotsFilled}.

\subsubsection{Panel informacyjny \texttt{BP\_MathText}}

Instrukcja zadania wyświetlana jest za pomocą blueprintu aktora \texttt{BP\_MathText}, w którym umieszczono blueprintowy widget \texttt{W\_MathText}.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/algebraic.png}
    \caption{Wygląd pokoju algebraicznego}
    \label{fig:Lamp}
\end{figure}
\subsection{Przebieg zadania}

Po rozpoczęciu zadania gracz znajduje się w pokoju i widzi na panelu informacyjnym \texttt{BP\_MathText} komunikat:
\begin{quote}
„Połącz odpowiednie początki i końce wzorów skróconego mnożenia. Przeciągnij klocki we właściwe miejsca.”
\end{quote}

Jeżeli gracz podniesie obiekt z formułą i spróbuje umieścić go w slocie, w momencie wejścia obiektu w obszar \texttt{Box Collision} slotu, obiekt tymczasowo przejmuje materiał slotu. 
Jeżeli w tym momencie gracz upuści obiekt, zostaje on automatycznie umieszczony w slocie. 
Rozwiązanie to zostało zastosowane w celu ułatwienia precyzyjnego umieszczania obiektów. 
Jeżeli gracz wyciągnie obiekt z obszaru kolizji slotu, jego materiał zostaje przywrócony do pierwotnego stanu.

W momencie umieszczenia obiektu w slocie tablicy \texttt{BP\_MathBoard}, zmienna \texttt{Slot[i]IsNoFull} przyjmuje wartość \texttt{False}, co uniemożliwia umieszczenie innego obiektu w tym samym slocie do momentu usunięcia aktualnie umieszczonego klocka.

Gracz w dowolnym momencie może nacisnąć przycisk \texttt{BP\_CheckMath}, który po interakcji odtwarza animację wciśnięcia oraz wywołuje funkcję \texttt{AreAllSlotsFilled}. 
Funkcja ta w pierwszej kolejności sprawdza, czy wszystkie sloty zostały uzupełnione. 
Jeżeli nie, do widgetu \texttt{W\_MathText} wysyłany jest komunikat:
\begin{quote}
„Nie wszystkie formuły są jeszcze uzupełnione. Połącz każdą część początkową z odpowiednim zakończeniem.”
\end{quote}

Jeżeli wszystkie sloty są uzupełnione, funkcja sprawdza poprawność wzorów poprzez porównanie identyfikatora \texttt{FormulaID} obiektu z identyfikatorem \texttt{ExpectedID} slotu. 
W przypadku poprawnego dopasowania wyświetlany jest komunikat:
\begin{quote}
„Świetnie! Poprawnie połączyłeś wzory skróconego mnożenia.”
\end{quote}
Zadanie zostaje zaliczone, a gra przechodzi do kolejnego poziomu.

W przeciwnym przypadku wyświetlany jest komunikat:
\begin{quote}
„Części formuł zostały połączone niepoprawnie. Spróbuj dobrać inne pary.”
\end{quote}
Gracz może ponawiać próby do momentu poprawnego rozwiązania zadania.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Zadanie 2 – Planimetria (Jan Walczak)}
\label{sec:planimetria_praktyka}

\subsection{Problemy i różnice w realizacji zadania w praktyce}
Podczas implementacji zadania, zgodnie z teorią opisaną w podrozdziale \ref{subsec:planimetria_teoria},
wystąpiło kilka problemów. Przede wszystkim zauważono, że odpowiedzi są zero-jedynkowe.
Przykładowo: uczeń ma do uzupełniania relację typu \glqq każdy kwadrat ... prostokątem\grqq. Jeśli 
odpowie niepoprawnie, tj. zaznaczy odpowiedź \glqq nie jest\grqq, a zostanie od razu zapytany ponownie, o tę
samą relację, to od razu wyklucza jedną z odpowiedzi. Tym samym zadanie zatraca swoją wartość edukacyjną
-- uczeń może rozwiązać całe zadanie, stosując jedynie metodę eliminacji.

Rozwiązanie tego problemu, które zostało zaimplementowane, to zdefiniowanie puli takich relacji i po udzieleniu
przez ucznia odpowiedzi, każdorazowe losowanie relacji innej niż ta poprzednia.
W ten sposób uniemożliwia się uczniowi stosowanie zasady eliminacji i wymusza na nim prawidłowe podejście.

Kolejnym problemem była prezentacja zadania. Zwykła tabela, którą uczeń miałby uzupełniać, mogłaby wydać mu się
mało ciekawa. Tym samym postanowiono wizualnie usprawnić zagadkę. Na środku zostały umieszczone dwa przyciski:
\begin{itemize}
    \item każdy
    \item nie każdy
\end{itemize}
Uczeń zostaje poinstruowany, że po obu ścianach pokoju zostaną wyświetlone różne figury geometryczne. Po lewej stronie,
patrząc od przycisków -- figury oznaczone kolorem czerwonym, po prawej stronie -- figury oznaczone kolorem zielonym.
Liczba figur jest stała. Każdorazowo typ wyświetlanych figur jest wybierany z określonej puli i wyświetlany w pseudolosowej 
konfiguracji -- losowane jest ich położenie, obrót oraz rozmiar. Zadaniem ucznia jest uzupełnianie kolejnych relacji poprzez
wybieranie odpowiednich przycisków. Relacja, wyświetlana na ścianie pokoju, przedstawia się jako:
\glqq każdy typ figury, narysowany kolorem czerwonym, jest równocześnie typem figury oznaczonym kolorem zielonym\grqq.
Dodatkowo tekst jest odpowiednio pokolorowany tak, aby uczeń nie miał wątpliwości, że chodzi o typ figury, wyświetlanej tymże kolorem
na ścianach.

\subsection{Implementacja struktury danych przechowującej relację}
Na początku pracy należało zdefiniować strukturę, przechowującą relacje, czyli pytania, na które uczeń
będzie odpowiadał. Relacja taka zawiera następujące pola:

\begin{itemize}
    \item \verb|Every| -- wartość logiczna
    \item \verb|FigureA| -- ciąg tekstowy, reprezentujący pierwszą figurę w relacji
    \item \verb|FigureB| -- ciąg tekstowy, reprezentujący drugą figurę w relacji
\end{itemize}

Wartość zmiennej \verb|Every| odpowiada na pytanie, \glqq czy każda figura typu pierwszego (\verb|FigureA|) jest równocześnie
figurą typu drugiego (\verb|FigureB|)?\grqq. Struktura zawiera również funkcję słownikową, czyli taką, która tłumaczy wartości
tekstowe na liczbowe.

\subsection{Implementacja kontrolerów}
Aby zarządzać zagadką została zaimplementowana seria kontrolerów i menedżerów.
\begin{itemize}
    \item \verb|ControlerFigures| (główny kontroler)
    \item \verb|FiguresTextManager|
    \item \verb|WallFigures|
\end{itemize}

\verb|WallFigures| to najprostszy z kontrolerów, wykonuje polecenia głównego kontrolera. Jego zadaniem jest 
wyświetlanie żądanych figur i ich losowe ustawianie w świecie gry (obracanie, skalowanie, rozmieszczanie). W projekcie występują
jego dwie instancje: kontroler lewy i prawy. Odpowiadają one za odpowiednie ściany, na których wyświetlane są figury.

\verb|FiguresTextManager| jest odpowiedzialny za zarządzanie tekstem wyświetlanym na ekranie. Wykonuje polecenia
głównego kontrolera. Jego zadaniem jest odpowiednie wyświetlanie i kolorowanie tekstu.

\verb|ControlerFigures|, czyli kontroler główny, jest najważniejszym elementem zagadki. Zawiera referencję do pozostałych
kontrolerów, zarządza obiektami wyświetlanymi na scenie i kontroluje przebieg zadania. Dodatkowo zawiera dwustronną
referencję do przycisków (\verb|Button|), które wysyłają do niego powiadomienia o tym, że zostały naciśnięte.
Kontroler zawiera też predefiniowaną tablicę relacji typów figur opisanych wcześniej.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.7\textwidth]{images/planimetreia_UML.png}
    \caption{Diagram UML zawierający najważniejsze elementy kontrolerów dla zadania 2 -- planimetria.}
    \label{planimetria:uml}
\end{figure}

\FloatBarrier

\subsection{Przebieg zadania}
Główny kontroler jest odpowiedzialny za inicjalizację zadania. Uruchamia on funkcję 
\verb|InitBlueprint|, odpowiedzialną za wywołanie odpowiednich funkcji podrzędnych 
elementów, takich jak: ustawienie tekstu, inicjalizacja ścian i przycisków.

Kontroler oczekuje na otrzymanie powiadomienia od przycisku odpowiedzialnego za uruchomienie gry.
Kiedy otrzyma powiadomienie, przesłane mu za pośrednictwem odpowiedniej funkcji, uruchamia grę, tj. wywołuje
funkcje podrzędnych komponentów, ustawiając im odpowiednią widoczność w świecie gry.

Z predefiniowanej tablicy relacji zostaje wybrana jedna, która zostaje wyświetlona graczowi
Główny kontroler czeka na powiadomienia od przycisków. Kiedy zostaje powiadomiony o tym, że jeden z nich został naciśnięty
sprawdza poprawność odpowiedzi. Jeśli odpowiedź jest poprawna, usuwa relację z tablicy i  losuje kolejną. Jeśli nie jest poprawna,
losuje kolejną relację do wyświetlenia graczowi i nie zalicza punktu. Gra kończy się po poprawnym uzupełnieniu przez gracza wszystkich relacji.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.7\textwidth]{images/planimetria_FLOW.png}
    \caption{Diagram przepływu dla zadania 2 -- planimetria}
    \label{planimetria:flow}
\end{figure}

\FloatBarrier
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





\section{Zadanie 3 – Nierówności (Konrad Czarnecki)}
\label{subsec:nierownosci_praktyka}
\subsection{Problemy i różnice w realizacji zadania w praktyce}
Podczas implementacji zadania, zgodnie z teorią opisaną w podrozdziale \ref{subsec:nierownosci_teoria},
ze względów estetycznych zmieniono postać, która miała być przeprowadzana przez most, na metaliczną kostkę,
która zamiast przesuwania się po kolejnych kafelkach, obraca się wzdłuż swojej krawędzi, tym samym zmieniając
swoją pozycję. 

\subsection{Główny kontroler}
Zadaniem głównego kontrolera jest zarządzanie przebiegiem całego zadania. Porusza kostką w kierunkach wskazanych
przez gracza, sprawdza poprawność ruchów, informuje o porażce lub zwycięstwie, zrzuca kafelki, które nie spełniają
wylosowanej nierówności, jeśli gracz pokierował na nie kostkę, a także blokuje niedozwolone ruchy,
takie jak opuszczenie mostu przez jego krawędź lub wejście w dziurę po kafelku, który wcześniej spadł – takie błędy
świadczyłyby o przypadkowych, niezamierzonych akcjach, a nie o braku matematycznej wiedzy.

Kiedy gracz dotrze do punktu kontrolnego w połowie mostu, główny kontroler zapisuje tę informację i podświetla
punkt kontrolny na zielono (rys. \ref{fig:punkt_kontrolny_pokoj_3}), aby w przypadku porażki w dalszej części mostu,
kostka mogła zostać cofnięta do tego punktu, a nie do samego początku. Odblokowanie punktu kontrolnego uniemożliwia
również cofnięcie się do pierwszej sekcji mostu.

Główny kontroler przechowuje także zmienną \verb|real Position|, która określa aktualną pozycję kostki na moście
względem kafelków, niezależnie od jej fizycznego położenia w świecie gry, które może być niewystarczająco
precyzyjne. Zatem, gdy gracz przesunie kostkę o jeden kafelek w przód, wartość parametru $y$ zmiennej \verb|real Position|
zostanie zwiększona o jeden. Cofanie zmniejszy wartość tego parametru o jeden, a ruchy w lewo i prawo odpowiednio
zmienią wartość parametru $x$.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.75\textwidth]{images/punkt_kontrolny_pokoj_3.png}
    \caption{Punkt kontrolny w pokoju 3}
    \label{fig:punkt_kontrolny_pokoj_3}
\end{figure}

\subsection{Wybór kafelków i układ nierówności}
Gracz może przesuwać kostkę jedynie po kafelkach, które są oznaczone liczbami spełniającymi wybrany układ nierówności.
W celu zwiększenia różnorodności rozgrywki, układ nierówności jest wybierany w sposób losowany ze zdefiniowanego
wcześniej zbioru.

\medskip
Lista układów nierówności oraz ich rozwiązań:
\begin{itemize}[left=1.5em, label=\textbullet, topsep=0pt, itemsep=0pt]
    \item $3x-4<11$; $x+1>-2$; rozwiązania całkowite: $-2$, $-1$, $0$, $1$, $2$, $3$, $4$
    \item $2x-5>-1$; $x-3<6$; rozwiązania całkowite: $3$, $4$, $5$, $6$, $7$, $8$
    \item $x+7>2$; $-x+1>-3$; rozwiązania całkowite: $-4$, $-3$, $-2$, $-1$, $0$, $1$, $2$, $3$
\end{itemize}
\medskip

W związku z faktem, że zbiory liczb spełniające układ nierówności różnią się w zależności od układu, który zostanie
wylosowany, a liczby na kafelkach zawsze pozostają te same, należało odpowiednio dobrać kafelki, tak aby w
każdym z przypadków istniała droga przez obie sekcje mostu (rys. \ref{fig:pokoj3_rozwiazanie}).

\begin{figure}[H]
\centering
\begin{minipage}{0.3\textwidth}
	\centering
	\includegraphics[width=\linewidth]{images/rozwiazanie1_pokoj_3.png}
	\vspace{0.3em}
	\small (a) Rozwiązanie dla $x \in [-2,\,4]$
\end{minipage}
\hspace{0.01\textwidth}
\vrule
\hspace{0.01\textwidth}
\begin{minipage}{0.3\textwidth}
	\centering
	\includegraphics[width=\linewidth]{images/rozwiazanie2_pokoj_3.png}
	\vspace{0.3em}
	\small (b) Rozwiązanie dla $x \in [3,\,8]$
\end{minipage}
\hspace{0.01\textwidth}
\vrule
\hspace{0.01\textwidth}
\begin{minipage}{0.3\textwidth}
	\centering
	\includegraphics[width=\linewidth]{images/rozwiazanie3_pokoj_3.png}
	\vspace{0.3em}
	\small (c) Rozwiązanie dla $x \in [-4,\,3]$
\end{minipage}

\caption{Ścieżki przejścia przez obie sekcje mostu dla każdego z układów nierówności}
\label{fig:pokoj3_rozwiazanie}
\end{figure}

\subsection{Przebieg zadania}
Zadanie rozpoczyna się wraz z wywołaniem funkcji \verb|Put On Tiles|, która ustawia kafelki z liczbami w odpowiednich pozycjach,
budując z nich most, a także w losowy sposób wybiera układ nierówności, który gracz będzie musiał wykorzystać.
Następnie główny kontroler wywołuje funkcję \verb|Died|, która ustawia kostkę na początku mostu w pozycji
wyjściowej (rys. \ref{fig:uklad_wspolrzednych_pokoj_4}). Most dzieli się na dwie sekcje oddzielone bezpiecznym punktem kontrolnym – jeśli gracz przegra w
drugiej sekcji, kostka zostanie cofnięta do punktu kontrolnego, a nie do samego początku.

Po wstępnej konfiguracji rozpoczyna się właściwa część zagadki. Gracz dysponuje czterema przyciskami (rys. \ref{fig:przyciski_pokoj_3}), odpowiadającymi
czterem kierunkom (w przód, w tył, w lewo i w prawo), które po naciśnięciu wywołują funkcję \verb|turn Side| z odpowiednim
parametrem w głównym kontrolerze. Jego zadaniem jest przeprowadzenie kostki przez most, poruszając się jedynie
po kafelkach, których liczby spełniają wylosowaną nierówność. Jeśli kostka stanie na kafelku, który nie spełnia
nierówności, kafelek i kostka spadają w przepaść, a gracz musi zacząć od początku, lub od punktu kontrolnego,
w zależności, w której sekcji mostu popełnił błąd.

Niemożliwe jest wypadnięcie z mostu poprzez wyjście poza jego krawędzie, lub wejście w dziurę po kafelku, który
wcześniej spadł – gra uniemożliwia takie ruchy. 

Po przejściu obu sekcji mostu, wszystkie pozostałe kafelki spadają do przepaści, a zagadka zostaje uznana za rozwiązaną (rys. \ref{fig:wygrana_pokoj_3}).

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.5\textwidth]{images/pozycja_poczatkowa_pokoj_3.png}
    \caption{Most podzielony na dwie sekcje w pokoju 3}
    \label{fig:pozycja_poczatkowa_pokoj_3}
\end{figure}
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.5\textwidth]{images/przyciski_pokoj_3.png}
    \caption{Przyciski do poruszania kostką w pokoju 3}
    \label{fig:przyciski_pokoj_3}
\end{figure}
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.5\textwidth]{images/wygrana_pokoj_3.png}
    \caption{Rozwiązany pokój 3}
    \label{fig:wygrana_pokoj_3}
\end{figure}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





\section{Zadanie 4 – Funkcje (Konrad Czarnecki)}
\label{subsec:funkcje_praktyka}
\subsection{Problemy i różnice w realizacji zadania w praktyce}
Jedyną istotną zmianą zadania względem opisu teoretycznego w podrozdziale \ref{subsec:funkcje_teoria} było rozdzielenie zagadki
czwartej i piątej na dwa oddzielne pokoje. Pierwotnie oba zadania miały być realizowane w jednym pomieszczeniu, jednak aby udostępnić
graczowi większą przestrzeń, zdecydowano się to zmienić.

\subsection{Wybór dostępnych punktów}
Zadanie składa się z trzech części. W każdej liczba punktów, które należy przeciąć wykresem funkcji zwiększa się o jeden, gracz otrzymuje dodatkowy suwak, pozwalający mu modyfikować następny współczynnik.
Losowe punkty, które gracz ma za zadanie przeciąć, są wybierane z wcześniej
zdefiniowanego zbioru. Zbiór ten został dobrany w taki sposób, aby współczynniki, które należy dobrać zawsze były liczbami całkowitymi,
aby poziom trudności rósł wraz z kolejnymi częściami zadania, oraz by gracz musiał wykorzystywać wszystkie dostępne suwaki. Zatem części drugiej
(z dwoma punktami do przecięcia i dwoma suwakami) nie da się rozwiązać, wykorzystując jedynie pierwszy suwak
odpowiedzialny za współczynnik $C$. Analogicznie, część trzecia (z trzema punktami do przecięcia i trzema suwakami)
wymaga wykorzystania wszystkich dostępnych suwaków.

\medskip
Lista możliwych punktów do przecięcia w każdej części zadania:
\begin{enumerate}[left=1.5em, topsep=0pt, itemsep=0pt]
    \item Część pierwsza (jeden punkt):
    \begin{itemize}[left=1.5em, label=\textbullet, topsep=0pt, itemsep=0pt]
        \item $P_1(4; 3)$; rozwiązanie: $f(x) = 3$
        \item $P_1(-3; 5)$; rozwiązanie: $f(x) = 5$
        \item $P_1(5; -1)$; rozwiązanie: $f(x) = -1$
        \item $P_1(2; -4)$; rozwiązanie: $f(x) = -4$
        \item $P_1(-3; 2)$; rozwiązanie: $f(x) = 2$
    \end{itemize}
    \item Część druga (dwa punkty):
    \begin{itemize}[left=1.5em, label=\textbullet, topsep=0pt, itemsep=0pt]
        \item $P_1(-1; 2)$; $P_2(0; 5)$; rozwiązanie: $f(x) = 3x + 5$
        \item $P_1(1; -2)$; $P_2(3; 2)$; rozwiązanie: $f(x) = 2x - 4$
        \item $P_1(-2; 1)$; $P_2(-3; 3)$; rozwiązanie: $f(x) = -2x -3$
        \item $P_1(-1; 6)$; $P_2(1; -2)$; rozwiązanie: $f(x) = -4x + 2$

    \end{itemize}
    \item Część trzecia (trzy punkty):
    \begin{itemize}[left=1.5em, label=\textbullet, topsep=0pt, itemsep=0pt]
        \item $P_1(-1; 5)$; $P_2(1; 5)$; $P_3(0; 2)$; rozwiązanie: $f(x) = 3x^2 + 0x + 2$
        \item $P_1(-1; -2)$; $P_2(0; -2)$; $P_3(-2; 4)$; rozwiązanie: $f(x) = 3x^2 + 3x - 2$
        \item $P_1(0; 2)$; $P_2(2; 0)$; $P_3(-1; -3)$; rozwiązanie: $f(x) = -2x^2 + 3x + 2$
        \item $P_1(-1; 6)$; $P_2(-2; 4)$; $P_3(-3; -2)$; rozwiązanie: $f(x) = -2x^2 - 4x + 4$
    \end{itemize}
\end{enumerate}
\medskip

\subsection{Przebieg zadania}
Zadanie rozpoczyna się zainicjalizowaniem i wstępną konfiguracją kanwy, na której wyświetlany będzie
układ współrzędnych. Następnie główny kontroler wywołuje funkcję \verb|Random Points|, która losowo wybiera
współrzędne punktu, który gracz będzie musiał przeciąć funkcją, z wcześniej zdefiniowanego zbioru i wypisze je na podłodze pomieszczenia. Wzór funkcji
\( f(x) = Ax^2 + Bx + C \) (gdzie współczynniki $A$, $B$ i $C$ są domyślnie ustawione na $0$)
zostaje wypisany na ścianie, a jej wykres, jak i wybrany wcześniej punkt narysowany w kanwie (rys. \ref{fig:uklad_wspolrzednych_pokoj_4}).

W pierwszej części gracz ma do dyspozycji jeden suwak – odpowiadający za współczynnik $C$. Jego zadaniem jest przesunięcie
wykresu funkcji w górę lub w dół tak, aby przeciął on wylosowany punkt. Po rozwiązaniu pierwszej części, główny kontroler
ponownie wywołuje funkcję \verb|Random Points|, tym razem losując współrzędne dwóch punktów, a gracz otrzymuje drugi suwak
– odpowiadający za współczynnik $B$. Teraz jego zadaniem jest ustawienie odpowiednich wartości obu współczynników, tak aby
wykres funkcji przeciął oba punkty jednocześnie. Ostatnia część jest analogiczna do poprzednich. \verb|Random Points|
losuje trzy punkty, a gracz dostaje do dyspozycji trzeci suwak – odpowiadający za współczynnik $A$ (rys. \ref{fig:wszystkie_suwaki_pokoj_4}) i musi dostosować
wzór paraboli, przecinając wszystkie trzy punkty.

W momencie zakończenia wszystkich trzech części zadania, zagadka zostaje uznana za rozwiązaną.
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.5\textwidth]{images/uklad_wspolrzednych_pokoj_4.png}
    \caption{Zainicjowany układ współrzędnych wraz z jednym punktem, który gracz musi przeciąć wykresem funkcji w pokoju 4}
    \label{fig:uklad_wspolrzednych_pokoj_4}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.75\textwidth]{images/wszystkie_suwaki_pokoj_4.png}
    \caption{Wszystkie suwaki dostępne w ostatnim etapie w pokoju 4}
    \label{fig:wszystkie_suwaki_pokoj_4}
\end{figure}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\section{Zadanie 5 – Geometria analityczna (Konrad Czarnecki)}
\label{subsec:geometria_analityczna_praktyka}
\subsection{Problemy i różnice w realizacji zadania w praktyce}
Tak samo jak w przypadku zagadki \ref{subsec:funkcje_praktyka} jedyną istotną zmianą zadania
względem opisu teoretycznego w podrozdziale \ref{subsec:geometria_analityczna_teoria} było
rozdzielenie zagadki
czwartej i piątej na dwa oddzielne pokoje.

\subsection{Kontroler przycisków}
Przyciski wyświetlane po obu stronach kanwy dysponują własnym kontrolerem, który powiadamia
kontroler główny za każdym razem, gdy któryś z nich zostanie naciśnięty. Kontroler ten obsługuje
też zmiany wprowadzane przez gracza, np. jeśli gracz naciśnie przycisk odpowiadający współczynnikowi
$x$ punktu przecięcia, równemu $3$, a następnie zmieni zadanie i wciśnie przycisk $4$ dla
współczynnika $x$, przycisk $3$ zostanie automatycznie odznaczony. Analogicznie działa to dla
przycisków współczynnika $y$.

W celu zachowania przestronności pomieszczenia, zdecydowano się zrezygnować z przycisków o
wartościach ujemnych i zamiast nich wprowadzić przycisk oznaczony symbolem $\pm$, który po
naciśnięciu zmienia znaki wszystkich innych przycisków w danej grupie ($x$ lub $y$) na przeciwne.

\subsection{Wybór dostępnych wzorów funkcji}
Zadanie składa się z trzech części. W każdej części gracz musi wyliczyć punkt przecięcia wykresów
funkcji i wcisnąć odpowiadające mu przyciski. W celu zwiększania poziomu trudności, w pierwszej
części obie funkcje są funkcjami liniowymi, w drugiej jedna z nich jest funkcją liniową, a druga
kwadratową, a w trzeciej obie funkcje są kwadratowe.

Losowe funkcje, których punkt przecięcia gracz ma za zadanie wyznaczyć, są wybierane z wcześniej
zdefiniowanego zbioru. Zbiór ten został dobrany w taki sposób, aby funkcje zawsze przecinały się
tylko w jednym miejscu (w przypadku funkcji kwadratowych drugi punkt przecięcia zawsze znajduje
się w dużej odległości poza zakresem widoczności kanwy).

\medskip
Lista możliwych wzorów przecinających się funkcji w każdej części zadania:
\begin{enumerate}[left=1.5em, topsep=0pt, itemsep=0pt]
    \item Część pierwsza (dwie funkcje liniowe):
    \begin{itemize}[left=1.5em, label=\textbullet, topsep=0pt, itemsep=0pt]
        \item $f_1(x) = 2x - 3$; $f_2(x) = -x + 6$; rozwiązanie: $P(3; 3)$
        \item $f_1(x) = -2x - 8$; $f_2(x) = 2x + 4$; rozwiązanie: $P(-3; -2)$
        \item $f_1(x) = -9x - 6$; $f_2(x) = 2x + 5$; rozwiązanie: $P(-1; 3)$
    \end{itemize}
    \item Część druga (jedna funkcja liniowa, jedna kwadratowa):
    \begin{itemize}[left=1.5em, label=\textbullet, topsep=0pt, itemsep=0pt]
        \item $f_1(x) = x^2 - 10x + 23$; $f_2(x) = 6x - 32$; rozwiązanie: $P(5; -2)$
        \item $f_1(x) = x^2 + 10x + 29$; $f_2(x) = -6x - 26$; rozwiązanie: $P(-5; 4)$
        \item $f_1(x) = x^2 - 6x + 14$; $f_2(x) = 8x - 19$; rozwiązanie: $P(3; 5)$
    \end{itemize}
    \item Część trzecia (dwie funkcje kwadratowe):
    \begin{itemize}[left=1.5em, label=\textbullet, topsep=0pt, itemsep=0pt]
        \item $f_1(x) = 2x^2 - 31x + 103$; $f_2(x) = x^2 - 10x + 23$; rozwiązanie: $P(5; -2)$
        \item $f_1(x) = 2x^2 - 19x + 36$; $f_2(x) = x^2 - 4x + 10$; rozwiązanie: $P(2; 6)$
        \item $f_1(x) = 2x^2 + 23x + 46$; $f_2(x) = x^2 + 6x + 4$; rozwiązanie: $P(-3; -5)$
    \end{itemize}
\end{enumerate}
\medskip

\subsection{Przebieg zadania}
Podobnie jak w przypadku czwartej zagadki, zadanie rozpoczyna się zainicjalizowaniem i wstępną
konfiguracją kanwy, na której wyświetlane będą układ współrzędnych oraz wzory funkcji. Następnie
główny kontroler wywołuje funkcję \verb|Random Points|, która losowo wybiera wzory dwóch
przecinających się funkcji z wcześniej zdefiniowanego zbioru. Wzory funkcji zostają wypisane na
podłodze, a ich wykresy narysowany w kanwie (rys. \ref{fig:uklad_wspolrzednych_pokoj_5}).

Gracz ma do dyspozycji rzędy przycisków po prawej i lewej stronie kanwy, których zadaniem jest
odpowiednio modyfikacja współczynników $x$ (rys. \ref{fig:przyciski_x_pokoj_5}) i $y$. Za plecami gracza znajdują się trzy rozświetlone
na czerwono lampy. Po rozwiązaniu każdej części zadania, jedna z lamp zmienia kolor na niebieski,
a funkcja \verb|Random Points| wybiera nowy zestaw funkcji.

W momencie zakończenia wszystkich trzech części zadania i rozświetlenia wszystkich lamp na
niebiesko, zagadka zostaje uznana za rozwiązaną.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.75\textwidth]{images/uklad_wspolrzednych_pokoj_5.png}
    \caption{Zainicjowany układ współrzędnych wraz z przecinającymi się wykresami funkcji w pokoju 5}
    \label{fig:uklad_wspolrzednych_pokoj_5}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.75\textwidth]{images/przyciski_x_pokoj_5.png}
    \caption{Przyciski odpowiedzialne za współrzędną $X$ w pokoju 5}
    \label{fig:przyciski_x_pokoj_5}
\end{figure}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Zadanie 6 – Kombinatoryka (Amdrii Demyshyn)}
\subsection{Różnice realizacji zadania w praktyce}
W koncepcji teoretycznej sejf zawierał jedną, stałą zagadkę matematyczną. 
Takie rozwiązanie powodowało, że po jednorazowym rozwiązaniu zadania element ten tracił swoją funkcję edukacyjną oraz rozgrywkową. 
W związku z tym zdecydowano się na rozbudowanie pierwotnej koncepcji poprzez wprowadzenie wielu zagadek kombinatorycznych obsługiwanych przez jeden, uniwersalny mechanizm sejfu.

\subsection{Zaimplementowane zagadki}

Zaimplementowano dwanaście zagadek kombinatorycznych, z których każda posiada przypisany indeks. 
Podczas uruchomienia gry indeks zagadki jest losowo generowany z przedziału od 0 do 11. 
Następnie treść wybranej zagadki wyświetlana jest za pomocą blueprintu aktora \texttt{BP\_RiddleSafe}, w którym umieszczony jest widget typu \texttt{WB\_ZagadkaText}. 
Poprawna odpowiedź ustawiana jest jako zmienna \texttt{CurrentCode}.

\begin{enumerate}
    \item \textbf{Zagadka 1:}  
    „PIN to liczba wszystkich możliwych 3-cyfrowych kodów PIN, w których żadna cyfra się nie powtarza.”  
    \textbf{Odpowiedź:} 720

    \item \textbf{Zagadka 2:}  
    „PIN to liczba wszystkich możliwych 4-cyfrowych kodów PIN, w których żadna cyfra się nie powtarza.”  
    \textbf{Odpowiedź:} 5040

    \item \textbf{Zagadka 3:}  
    „PIN to liczba wszystkich możliwych 4-cyfrowych kodów PIN bez powtórzeń, gdzie pierwsza cyfra nie może być zerem.”  
    \textbf{Odpowiedź:} 4536

    \item \textbf{Zagadka 4:}  
    „PIN to liczba wszystkich 4-cyfrowych kodów PIN, w których dokładnie jedna cyfra występuje dwa razy, a pozostałe dwie cyfry są różne od niej i od siebie (np. 1213).”  
    \textbf{Odpowiedź:} 4320

    \item \textbf{Zagadka 5:}  
    „PIN to liczba wszystkich 4-cyfrowych kodów PIN, które składają się z dokładnie dwóch różnych cyfr (obie muszą wystąpić co najmniej raz).”  
    \textbf{Odpowiedź:} 2100

    \item \textbf{Zagadka 6:}  
    „PIN to liczba wszystkich 4-cyfrowych kodów PIN będących palindromem (ABBA).”  
    \textbf{Odpowiedź:} 100

    \item \textbf{Zagadka 7:}  
    „PIN to liczba wszystkich 6-cyfrowych kodów PIN będących palindromem (ABCCBA).”  
    \textbf{Odpowiedź:} 1000

    \item \textbf{Zagadka 8:}  
    „PIN to liczba wszystkich 3-cyfrowych kodów PIN, w których dokładnie jedna cyfra występuje dwa razy.”  
    \textbf{Odpowiedź:} 270

    \item \textbf{Zagadka 9:}  
    „PIN to liczba wszystkich 4-cyfrowych kodów PIN, w których dokładnie dwie cyfry są parzyste.”  
    \textbf{Odpowiedź:} 3750

    \item \textbf{Zagadka 10:}  
    „PIN to liczba wszystkich 4-cyfrowych kodów PIN, w których suma cyfr wynosi dokładnie 10.”  
    \textbf{Odpowiedź:} 286

    \item \textbf{Zagadka 11:}  
    „PIN to liczba wszystkich 4-cyfrowych kodów PIN, w których cyfry są ustawione w ściśle rosnącym porządku.”  
    \textbf{Odpowiedź:} 210

    \item \textbf{Zagadka 12:}  
    „PIN to liczba wszystkich 5-cyfrowych kodów PIN, w których cyfry są ustawione w ściśle malejącym porządku.”  
    \textbf{Odpowiedź:} 252
\end{enumerate}

\subsection{Sejf}

Sejf został zrealizowany jako obiekt typu Blueprint Actor. 
Składa się on z komponentów \texttt{StaticMesh} tworzących obudowę sejfu oraz klawiaturę numeryczną, a także z wyświetlacza w postaci widgetu \texttt{WBP\_SafeDisplay}, który prezentuje wprowadzane cyfry oraz komunikaty zwrotne.

Klawiatura sejfu zawiera:
\begin{itemize}
    \item przyciski numeryczne od 0 do 9, których wciśnięcie powoduje wyświetlenie cyfry na ekranie,
    \item przycisk \texttt{DEL}, umożliwiający usunięcie ostatnio wprowadzonej cyfry,
    \item przycisk \texttt{CHECK}, służący do zatwierdzenia kodu.
\end{itemize}

Gracz wchodzi w interakcję z sejfem poprzez naciskanie przycisków. 
Aktualnie wprowadzany kod jest na bieżąco prezentowany na wyświetlaczu, co umożliwia kontrolę poprawności danych.

Każdy przycisk sejfu składa się z komponentu wizualnego typu \texttt{StaticMesh} oraz komponentu \texttt{Box Collision}, odpowiedzialnego za wykrywanie interakcji. 
Po wciśnięciu przycisku odtwarzana jest animacja oraz wywoływane zdarzenie przekazujące informację o wciśniętym elemencie do głównej logiki sejfu.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/sejf1.png}
    \caption{Wygląd sejfu}
    \label{fig:Lamp}
\end{figure}
\subsection{Zakończenie zadania}

Po wciśnięciu przycisku \texttt{CHECK} rozpoczyna się proces weryfikacji wprowadzonego kodu z wartością zmiennej \texttt{CurrentCode}. 
Jeżeli wartości są zgodne, sejf zostaje otwarty, co sygnalizuje poprawne rozwiązanie zagadki. 
W przypadku wprowadzenia błędnego kodu sejf pozostaje zamknięty, a na wyświetlaczu pojawia się komunikat „ERROR”. 
Gracz może ponowić próbę rozwiązania zagadki.

\subsection{Podsumowanie}

Zastosowanie jednego, rozszerzalnego mechanizmu sejfu umożliwiło implementację wielu zagadek kombinatorycznych w spójnym środowisku interaktywnym. 
Takie rozwiązanie znacząco zwiększa regrywalność gry oraz poprawia jej walory edukacyjne.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Zadanie 7 – Liczby rzeczywiste i działania na zbiorach liczbowych 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\texorpdfstring{\\}{ } (Jan Walczak)}
\label{sec:rzeczywiste_praktyka}
\subsection{Problemy i różnice w realizacji zadania w praktyce}
\label{subsec:rzeczywiste_problemy}
Podczas implementacji zadania, zgodnie z teorią opisaną w podrozdziale \ref{subsec:liczby_rzeczywiste},
należało wprowadzić względem niej kilka poprawek. Pierwotny mechanizm zakładał, że zamek umieszczony na skrzyni będzie
wyposażony w pola, w które uczeń wpisywałby odpowiednie cyfry -- liczby elementów danego podzbioru. W praktyce
okazało się to niemożliwe. Maksymalna liczba jednocyfrowa to 9, tym samym zadanie jest ograniczone do wyświetlania maksymalnie 9 liczb
rzeczywistych w pokoju. 

Zamysł został zmieniony i zamiast kłódki postanowiono umieścić elektroniczny zamek, wyposażony w klawiaturę.
W ten sposób otrzymano możliwość umieszczenia więcej niż 9 liczb w pokoju. Uczeń staje również przed dodatkowym wyzwaniem -- 
wywnioskować kolejność wpisywanych liczb zgodnie z podpowiedzią, umieszczoną na ścianie (patrz rysunek \ref{rzeczywiste:screen}).

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.7\textwidth]{images/liczby_rzeczywiste_screen.png}
    \caption{Zrzut ekranu -- skrzynia z zamkiem oraz podpowiedź na ścianie dla zadania 7.}
    \label{rzeczywiste:screen}
\end{figure}
\FloatBarrier

Zmienione zostały również liczby, które są rozmieszczone w pokoju. Aktualnie pojawiają się liczby: 
\textit{15; π; 4,5; √2; ¼; -3; 1; -7; ⅓ ; 9} Tym samym kombinacja prezentuje się następująco (kolejność zgodna z podpowiedzią 
na rysunku \ref{rzeczywiste:screen}):
\begin{itemize}
    \item \textit{N} (naturalne): \textit{15; 1; 9} – 3 liczby,
    \item \textit{C} (całkowite):  \textit{15; 1; 9; -3; -7} – 5 liczb,
    \item \textit{R} (rzeczywiste): wszystkie liczby – 10 liczb,
    \item \textit{W} (wymierne): \textit{15; 1; 9; -3; -7; 4,5; ¼; ⅓} – 8 liczb,
    \item \textit{NW} (niewymierne): \textit{π; √2} – 2 liczby.
\end{itemize}
Tym samym kombinacja do otwarcia sejfu to \textit{351082}.

Ostatnią rzeczą, która została zmieniona jest koncepcja drugiej części zadania. Mechanizm obracania bloczków został uznany za niepotrzebny,
ponieważ wybrane relacje są jednoznaczne -- są czytane zawsze od lewej do prawej strony. Niepoprawny obrót bloczka od razu sugeruje
błędną odpowiedź.

Spośród wszystkich relacji zostały wybrane dwie:
\begin{itemize}
    \item $N \subset Z \subset R$,
    \item $NW \cap W = \varnothing$,
\end{itemize}
Zostały one wybrane przez swoją charakterystykę. Pierwsza z nich pokazuje, jak kolejne zbiory zawierają się w sobie nawzajem,
a druga pokazuje rozłączność zbiorów liczb wymiernych i niewymiernych.
Gracz ma do dyspozycji 6 bloczków:
\begin{itemize}
    \item dwa bloczki z symbolem $\subset$,
    \item dwa bloczki z symbolem $\varnothing$,
    \item dwa bloczki z symbolem $\cap$
\end{itemize}
Bloczki mają mu służyć do uzupełnienia dwóch relacji wymienionych wyżej. Po ułożeniu relacji, poprawnie bądź nie, bloczki pozostają
do dyspozycji gracza.

\subsection{Implementacja zadania}

Został zaimplementowany jeden, główny kontroler \verb|RealNumbersController|. Zarządza on przebiegiem zadania, położeniem elementów na scenie 
oraz wyświetlaniem tekstu. Zawiera odpowiednie referencje do komponentów i odpowiada za poprawną inicjalizację.

Komponent \verb|Element| jest bloczkiem z odpowiednim symbolem relacji, \verb|Sejf| jest skrzynią, która przetrzymuje bloczki,
a \verb|WallQuestion| to płaska tablica (ścianka), na której wyświetlane są pytania w drugiej części zadania.

\verb|Sejf| zawiera jednostronną referencję do głównego kontrolera. Kontroler może zostać przez niego powiadomiony, że gracz
poprawnie wpisał kod. W ten sposób kontroler może sterować dalszym przebiegiem zadania. \verb|WallQuestion| zawiera dwustronną referencję
do głównego kontrolera. Mechanizm powiadomień działa tutaj podobnie ale kontroler może odpowiadać na otrzymywane powiadomienia, poprzez
wywoływanie odpowiednich funkcji.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.7\textwidth]{images/real_UML.png}
    \caption{Diagram UML zawierający najważniejsze elementy dla zadania 7 -- liczby rzeczywiste i działania na zbiorach liczbowych.}
    \label{rzeczywiste:UML}
\end{figure}
\FloatBarrier

\subsection{Przebieg zadania}
Zadanie rozpoczyna się od pierwszej części -- wpisania kodu do skrzyni. Kontroler inicjalizuje komponenty, a  na ścianach i na skrzyni 
zostają wyświetlone liczby opisane w \ref{subsec:rzeczywiste_problemy}. Gracz powinien policzyć ile liczb, z jakiego zbioru, jest 
wyświetlanych w pokoju i poprawnie wpisać kod. W doborze kolejności wpisywanych liczb pomaga mu podpowiedź umieszczona na ścianie.
Po poprawnym wpisaniu kodu, kontroler główny zostaje powiadomiony przez instancję skrzyni, że zadanie może przejść do następnego etapu.
Drzwi się otwierają a kontroler inicjalizuje 6 bloczków, opisanych w \ref{subsec:rzeczywiste_problemy} i ściankę z pytaniami \verb|WallQuestion|.
Zapisuje pozycję oraz obrót bloczków w świecie gry, tak aby możliwy był powrót do stanu początkowego.

Ścianka wykrywa kolizję z bloczkami, które gracz na niej umieszcza. W momencie kiedy zostaje uzupełniona w całości, tj. bloczki wypełniają 
miejsca na odpowiedzi, powiadamia kontroler o rozwiązaniu zadania. Kontroler decyduje czy odpowiedź gracza jest poprawna. W przypadku gdy 
jest, to przesyła do \verb|WallQuestion| powiadomienie o zmianie pytania na kolejne i zalicza punkt. Jeżeli odpowiedź nie jest poprawna, to
również powiadamia o tym ściankę, ale nie zalicza punktu. W obu przypadkach bloczki wracają na wcześniej zapisaną pozycję.
W zależności od poprawności udzielonej odpowiedzi, ścianka rozświetla się kolorem zielonym lub czerwonym, tak żeby gracz miał pewność, że udzielona
odpowiedź jest poprawna. Podczas sprawdzania stanu ścianki, tj. ustawienie bloczków przez gracza pytanie zostaje zablokowane, a gracz nie może
modyfikować swojej odpowiedzi (dokładać lub zabierać bloczków).

Kiedy gracz odpowie na oba pytania poprawnie, poziom zostaje uznany za zaliczony.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{images/real_FLOW.png}
    \caption{Diagram przepływu dla zadania 7 -- liczby rzeczywiste i działania na zbiorach liczbowych.}
    \label{rzeczywiste:FLOW}
\end{figure}
\FloatBarrier

\subsection{Implementacja mechanizmu uzupełniania ścianki}
Ścianka, czyli \verb|WallQuestion|, wykrywa kolizję z bloczkami, czyli \verb|Element|, w dwóch miejscach, w których będą one docelowo
umieszczone. Kiedy gracz przytrzyma bloczek nad jednym z dwóch wskazanych miejsc, uruchamiana jest odpowiednia funkcja \verb|StartCollision()|. 
W zależności od tego gdzie został umieszczony bloczek, sprawdzany jest aktualny stan ścianki -- czy w danym miejscu gracz umieścił już bloczek.
Jeśli tak, to ścianka nie pozwoli mu umieścić w tym miejscu kolejnego bloczka, dopóki nie wyjmie poprzedniego. Dzieje się tak za sprawą dwóch
zmiennych wartości logicznych: \verb|ActorHovered| i \verb|ActorLockedIn|. Oznaczają one kolejno: stan, w którym gracz trzyma bloczek nad ścianką
i stan, w którym gracz umieścił bloczek na ściance. W przypadku gdy \verb|ActorLockedIn| jest ustawione na wartość \verb|0|, to zapisywana
jest referencja bloczku, który został właśnie umieszczony. 

Dodatkowo informacja o tym, że gracz puścił bloczek, czyli zamierza go umieścić w danym miejscu, jest odpowiednio zapisywana w instancji bloczka.
Kiedy bloczek znajduje się w ręce gracza otrzymuje sygnaturę \verb|held|. Kiedy gracz go puści, sygnatura jest odbierana. Wyżej wymienione wartości
logiczne są ustawiane dopiero wtedy, kiedy sygnatura najpierw istniała (w instancji bloczka), a potem została z niej usunięta.

W przypadku, gdy gracz chce usunąć bloczek ze ścianki, sytuacja jest analogiczna. Tym razem jednak, sprawdzamy czy bloczek, który zabiera gracz,
jest tym znajdującym się na ściance, poprzez porównanie referencji. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\section{Zadanie 8 – Znaki funkcji trygonometrycznych (Konrad Czarnecki)}
\label{subsec:znaki_funkcji_trygonometrycznych_praktyka}
\subsection{Problemy i różnice w realizacji zadania w praktyce}
Podczas implementacji zadania zgodnie z opisem teoretycznym zawartym w podrozdziale \ref{subsec:znaki_funkcji_trygonometrycznych_teoria}
wprowadzono zmiany poprawiające estetykę i grywalność zagadki. 
Pierwotnie wszystkie cztery układy jednostkowe (oznaczone $sin(x)$, $cos(x)$, $tg(x)$ i $ctg(x)$) miały znajdować się na jednej ścianie, ale w celu uzyskania większej
przejrzystości każdy z nich umieszczono na oddzielnej. Dodano ruchome sześciany w dwóch wariantach: zielone –
oznaczone symbolami „+” oraz czerwone – oznaczone symbolami „–” (rys. \ref{fig:szesciany_pokoj_8}). Przyciski do zmiany znaku funkcji umieszczone
w czterech ćwiatrtkach układów jednostkowych zostały zastąpione lukami (rys. \ref{fig:uklad_jednostkowy_pokoj_8}), które gracz musi wypełnić wyżej
wspomniamymi sześcianami. Taka zmiana zwiększa poziom interakcji gracza z zagadką, co bezpośrednio przekłada
się na wyższy poziom zaangażowania oraz lepszą czytelność mechanik zadania.

Ze względu na ograniczony rozmiar Jaskini tylko jeden układ jednostkowy jest widoczny w danym czasie. 
Po wypełnieniu jego ćwiartek sześcianami opatrzonymi odpowiednimi symbolami, układ jednostkowy chowa się,
a zza innej ściany płynnie wysuwa się następny – ich kolejność jest losowa. W związku z tym liczba sześcianów
z symbolami dostępnych w jednym czasie w pomieszczeniu mogła zostać ograniczona do czterech – dwa oznaczone 
„+” i dwa oznaczone „–”. Pozwala to rozwiązać każdy poszczególny układ jednostkowy (rys. \ref{fig:cwiartki_ukladow_jednostkowych}).

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.5\textwidth]{images/szesciany_pokoj_8.png}
    \caption{Ruchome sześciany w pokoju 8}
    \label{fig:szesciany_pokoj_8}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.5\textwidth]{images/uklad_jednostkowy_pokoj_8.png}
    \caption{Układ jednostkowy w pokoju 8}
    \label{fig:uklad_jednostkowy_pokoj_8}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.5\textwidth]{images/wykryto_luke_pokoj_8.png}
    \caption{Sześcian po wykryciu luki w pokoju 8}
    \label{fig:wykryto_luke_pokoj_8}
\end{figure}

\subsection{Implementacja sześcianów}
Sześciany dysponują własnym kontrolerem, który powiadamia kontroler główny za każdym razem, gdy któryś sześcian
zostaje umieszczony w luce. Gracz może również wyjąć wcześniej umieszczony sześcian z luki i włożyć go w inną.
Ponadto kontroler zapobiega umieszczeniu dwóch sześcianów w tej samej luce, a także wyrzuceniu ich poza obszar
gry. W takim wypadku sześcian automatycznie pojawia się na środku pokoju, zapewniając ciągłość zagadki.

Kiedy gracz zbliży się do luki w układzie jednostkowym, trzymając sześcian, kolor sześcianu zmieni się na jaskrawo
żółty, informując gracza, że luka została wykryta (rys. \ref{fig:wykryto_luke_pokoj_8}). Jeśli w takim momencie gracz puści sześcian, uruchomi się płynna
animacja, w której ten automatycznie obróci się do odpowiedniego kąta i umieści w luce.

\subsection{Przebieg zadania}
Zadanie rozpoczyna się wywołaniem funkcji \verb|Random Order| przez główny kontroler. Funkcja ta w losowy sposób
ustala kolejność czterech układów jednostkowych funkcji trygonometrycznych, które gracz będzie musiał
rozwiązać. Następnie wykonuje się funkcja \verb|Reset Boxes Position|, która umieszcza ruchome sześciany
w rogach pomieszczenia, również w losowy sposób.

Po tej wstępnej konfiguracji rozpoczyna się właściwa część zadania. Pierwszy układ jednostkowy wyłania się zza
ściany, a gracz podnosi sześciany i umieszcza je w odpowiednich lukach. Za każdym razem wywoływana jest funkcja
\verb|Box Inside| informująca główny kontroler, że sześcian został umieszczony wewnątrz układu i sprawdzająca,
czy położenie wszystkich sześcianów jest poprawne. Kiedy to nastąpi układ jednostkowy chowa się, nazwa funkcji
trygonometrycznej nad nim rozświetla się na zielono, dając graczowi do zrozumienia, że element zagadki został
rozwiązany poprawnie, sześciany cofają się do swoich pozycji startowych funkcją \verb|Reset Boxes Position|,
a następnie pojawia się kolejny układ jednostkowy do rozwiązania.

Kiedy gracz wypełni wszystkie układy poprawnie, zagadka zostaje uznana za rozwiązaną.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Zadanie 9 – Ciągi liczbowe (Jan Walczak)}
\label{sec:ciągi_praktyka}
\subsection{Problemy i różnice w realizacji zadania w praktyce}
W przeciwieństwie do zadań opisanych w podrozdziałach \ref{sec:planimetria_praktyka} i \ref{sec:rzeczywiste_praktyka} w tym zadaniu nie 
pojawiło się  dużo rozbieżności między teorią, a praktyczną implementacją.

Miejsce, w którym wprowadzono modyfikację, to warunki zakończenia gry. Zadanie, przez swój projekt, stawia bardziej na szybką analizę, niż
na długie zastanawianie się nad odpowiedzią. Jest bezpośrednio inspirowane prawdziwą grą, w której największą wartością, wyróżniającą gracza, jest jego
czas reakcji. Z tego powodu zdecydowano się na usunięcie limitu czasowego. Gra przyspiesza liniowo, razem z postępem, tj. liczbą zestrzelonych przez
gracza kaczek.

Dodatkowo zwiększono liczbę żyć, tj. możliwości na pomyłkę gracza do 4 zamiast 3. Jest to spowodowane wprowadzeniem dodatkowej mechaniki gry -- jeśli
kaczka wyleci poza zasięg gracza (za ścianę), gracz traci życie. Gra kończy się jedynie w momencie utraty wszystkich żyć -- co musi nastąpić, ponieważ
prędkość kaczek będzie rosła tak długo, jak toczy się rozgrywka.

\subsection{Implementacja pistoletu laserowego}
Implementacja pistoletu laserowego była kluczowym punktem, potrzebnym do stworzenia całego poziomu. 

Aby poprawnie zaimplementować taki laser potrzebne są trzy wartości:
\begin{itemize}
    \item punkt początkowy, od którego zaczynamy rysowanie lasera,
    \item punkt końcowy, do którego laser będzie rysowany,
    \item wektor kierunkowy, według którego laser będzie rysowany.
\end{itemize}

Za punkt początkowy został obrany koniec ręki gracza, tj. kontrolera, którym steruje. Z ustawienia kontrolera w świecie gry można również 
wyznaczyć wektor kierunkowy. Należy pobrać z kontrolera wartość tego wektora, przy użyciu systemowej funkcji Unreal Engine \verb|Get Forward Vector|. 
Należy zapisać ten wektor, razem z punktem początkowym. Obliczenie punktu końcowego jest nieco trudniejsze. Polega na początkowym pomnożeniu 
wektora kierunkowego przez inny wektor, o dużych wartościach poszczególnych współrzędnych, a następnym dodaniu wyniku tego działania do 
współrzędnych punktu początkowego. W projekcie zastosowano wektor $(1000,0; 1000,0; 1000,0)$. Tak obliczony punkt należało chwilowo zapisać jako punkt końcowy.

Następnie, przy użyciu systemowej funkcji \verb|Line Trace by Channel|, należało wyznaczyć punkt, w którym linia, poprowadzona od punktu
początkowego do końcowego, przecina się ze światem przedstawionym w grze. Funkcja ta zwraca wynik w postaci wartości typu struktury \verb|Hit Result|, 
który można rozbić na składowe i pozyskać z niego \verb|Impact Point|, czyli rzeczywisty punkt końcowy oraz \verb|Distance|, czyli 
wartość zmiennoprzecinkową, reprezentującą długość wyznaczonej linii.

Dzięki obliczonym wartościom można narysować laser, przebiegający od kontrolera gracza, do pierwszego napotkanego obiektu w grze. W tym celu kontroler ma
na stałe przypisany obiekt \verb|Static Mesh|, z siatką statyczną w kształcie cylindra, który jest rozciągany zgodnie z obliczonymi wartościami. Nałożony jest
na niego materiał, emitujący czerwone światło. Na końcu rozciągniętej siatki statycznej umieszczona jest niewidzialna kulka, z włączonym systemem kolizji. 
Dzięki niej można wykrywać, w jaki komponent na scenie aktualnie celuje gracz.

Na rysunku \ref{fig:sequence_laser} widać, że laser faktycznie wykrywa otoczenie, w które celuje gracz i zmienia odpowiednio swoją długość. Zmianie
ulega również kierunek, w którym celuje gracz.
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.7\textwidth]{images/sequence_laser.png}
    \caption{Porównanie rysowania lasera w przypadku kontaktu z przykładowym elementem otoczenia i ścianą.}
    \label{fig:sequence_laser}
\end{figure}

\subsection{Implementacja zadania}

Zaimplementowany został jeden, główny kontroler \verb|SequenceControler|.
Jego zadaniem jest inicjalizacja gry, zarządzanie przebiegiem gry, wyświetlanie tekstu i zarządzanie instancjami kaczek. Kontroler wybiera pseudolosowo
jeden z trzech dostępnych wzorów, na kolejny wyraz ciągu arytmetycznego, według którego będą obliczane kolejne elementy. Dostępne są wzory:
\begin{itemize}
    \item $a_n = 3n + 4$
    \item $a_n = 2n + 3$
    \item $a_n = 5n + 7$
\end{itemize}

Komponent \verb|Duck| implementuje funkcjonalności związane ze sterowaniem pojedynczej kaczki. Zawiera dwustronną referencję, do obiektu głównego kontrolera
i przesyła powiadomienia, kiedy zostanie zestrzelony przez gracza, przy użyciu pistoletu laserowego. W instancji kaczki zapisywana jest pozycja początkowa, numer,
który aktualnie jest na niej wyświetlany i wartość zmiennoprzecinkowa, czyli droga, którą pokona kaczka w każdej jednostce czasu w grze.

Gracz zostaje również zapoznany z zasadami działania gry. Kiedy jest gotowy do rozpoczęcia gry naciska przycisk, podobny do tego opisanego w podrozdziale 
\ref{sec:planimetria_praktyka}. Przycisk działa na tej samej zasadzie i również posiada dwustronną referencję do instancji kontrolera.

W zagadce występują jeszcze dwa komponenty: \verb|HitWall| i \verb|Life|. Główny kontroler zawiera tablicę referencji do 4 
instancji obiektów \verb|Life|. Reprezentują ilość pozostałych żyć gracza i nie pełnią w logice działania programu żadnej 
istotnej roli, poza tą wizualną. \verb|HitWall| jest obiektem niewidocznym, znajdującym się poza zasięgiem gracza. Lecące 
kaczki będą wykrywać ten obiekt i sygnalizować to głównemu kontrolerowi zderzenie tak, jakby zostały trafione. Jeżeli kaczka uderzy w 
ten komponent, wyśle specjalny typ powiadomienia, mówiący o tym, że graczowi nie udało się jej zestrzelić. Jeśli kaczka 
zawierała poprawny wyraz ciągu to kontroler odczyta to jako błąd gracza i odejmie mu jedno życie. W takim przypadku, jeżeli 
gracz ma jeszcze pozostałe życia, wyświetli się kolejny wyraz ciągu, a kaczki zaczną lecieć od początku.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.7\textwidth]{images/sequence_UML.png}
    \caption{Diagram UML zawierający najważniejsze elementy dla zadania 9 -- Ciągi liczbowe.}
    \label{fig:sequence_UML}
\end{figure}

\subsection{Przebieg zadania}
Zadanie rozpoczyna się od inicjalizacji komponentów przez główny kontroler.  Początkowo graczowi zostaje
wyświetlona instrukcja do zadania. Kiedy gracz będzie gotowy może rozpocząć grę naciskając przycisk \glqq
Start\grqq. Kontroler zostaje w takiej sytuacji powiadomiony przez instancję przycisku i rozpoczyna grę. W sposób 
pseudolosowy zostaje wybrany jeden z trzech wzorów na kolejny \textit{n-ty} wyraz ciągu arytmetycznego. Kontroler ustawia również
poprawny wyraz ciągu, początkowo $n = 0$, na jednej z trzech kaczek. Pozostałe kaczki otrzymują wyrazy większe
lub mniejsze od poprawnego wyrazu, również w sposób pseudolosowy. Dzieje się to wedle zasady, że wybrane wyrazy mogą być
odległe jedynie o 2 jednostki na osi współrzędnych od poprawnego wyrazu ($a_n \pm 2$).

Kaczki pokonują stałą jednostkę odległości, w każdej jednostce czasu wykonywania się programu, wyrażoną za pomocą
liczby zmiennoprzecinkowej. Jednostka ta jest tym większa, im większy jest aktualny numer wyrazu ciągu
arytmetycznego. Oznacza to, że będą przyspieszać razem z przebiegiem gry. Do tak obliczonej stałej wartości,
dodawana jest pseudolosowa wartość zmiennoprzecinkowa wybrana pseudolosowo z przedziału $\left[0,5; 0,7\right] $. 

Kaczki poruszają się od lewej do prawej strony ekranu, aż do zderzenia się z instancją obiektu \verb |HitWall|. 
Kaczki mogą zostać zestrzelone przez gracza, zanim zderzą się z wyżej wymienionym obiektem. 
W obu przypadkach do kontrolera wysyłane jest powiadomienie odpowiedniego rodzaju: 
kaczka została zestrzelona lub kaczka  zderzyła się z obiektem \verb|HitWall|. 
W powiadomieniu przekazana jest również liczba całkowita, która znajdowała się na danej kaczce. 

Kontroler po otrzymaniu w powiadomieniu liczby oraz informacji, czy dana kaczka została zestrzelona, 
podejmuje decyzję:
\begin{enumerate}
  \item Jeśli liczba jest poprawnym wyrazem ciągu -- zalicza punkt i ustawia ponownie kaczki. Zwiększa też numer wyrazu ciągu.
  \item Jeśli liczba nie jest poprawna -- odejmuje jedno życie, ale nie ustawia ponownie kaczek.
  \item Jeśli kaczka, przechowująca poprawny wyraz ciągu, uderzy w obiekt \verb|HitWall| (wyleci poza 
  zasięg gracza) -- odejmuje jedno życie i ponownie ustawia kaczki. Zwiększa też numer wyrazu ciągu.
\end{enumerate}
Ponowne ustawienie kaczeek polega na obliczeniu kolejnego wyrazu ciągu arytmetyczngo, ustawieniu go na 
jednej z nich, ustawieniu dwóm pozostałym kaczkom błędnego wyrazu oraz na cofnięciu ich do stanu 
początkowego. Gra kończy się w momencie, gdy gracz straci wszystkie 4 życia.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{images/sequence_FLOW.png}
    \caption{Diagram przepływu dla zadania 9 -- Ciągi liczbowe }
    \label{sequence:flow}
\end{figure}

\section{Zadanie 10 – Prawdopodobieństwo (Autor)}
\section{Zadanie 11 – Optymalizacja i rachunek różniczkowy (Autor)}
\section{Zadanie 12 – Układy równań (Andrii Demyshyn)}
\subsection{Różnice realizacji zadania w praktyce}
W tym zadaniu zrealizowano zagadkę matematyczną opartą na osiągnięciu zadanej wartości energetycznej niezbędnej do zapalenia żarówki. 
Zadaniem gracza jest umieszczenie odpowiedniej liczby kulek każdego koloru w pojemnikach w taki sposób, aby łączna wartość energetyczna kulek była równa wartości wskazanej nad żarówką.

W trakcie opracowywania zadania zdecydowano się na zmianę logiki zagadki. 
Początkowo planowano implementację rozwiązania posiadającego tylko jedno poprawne rozwiązanie, co nadawałoby grze charakter jednorazowy. 
We wcześniejszej koncepcji docelowa wartość energii była stała, a gracz musiał umieścić dokładnie 12 kulek w kontenerach. 
W toku realizacji podjęto decyzję o zwiększeniu różnorodności rozgrywki poprzez losowanie wartości docelowej z przedziału od 18 do 51. 
W obecnej wersji zagadki gracz sam decyduje o liczbie umieszczanych kulek, pod warunkiem że ich łączna wartość energetyczna odpowiada liczbie wyświetlanej nad żarówką. 
Dzięki tym zmianom zagadka stała się bardziej zróżnicowana i wielokrotnego użytku.

Po wejściu do pokoju gracz widzi lampę, trzy pojemniki na kulki, zestaw kolorowych kulek oraz panel informacyjny z instrukcją zadania. 
Nad lampą wyświetlana jest docelowa wartość energii, którą należy osiągnąć.

\subsection{Opis obiektów sceny}

\subsubsection{Panel informacyjny \texttt{BP\_RiddleText}}

W pokoju umieszczono panel informacyjny w postaci blueprintu aktora \texttt{BP\_RiddleText}, wewnątrz którego znajduje się blueprintowy widget \texttt{ZagadkaLamp}. 
W widżecie wyświetlana jest instrukcja zadania:

\begin{quote}
„Aby uruchomić oświetlenie, należy włożyć do pojemników taką liczbę kulek, aby łącznie wygenerowana moc była dokładnie równa wartości wyświetlanej nad lampą.  
Jeśli moc będzie zbyt niska lub zbyt wysoka — instalacja nie zadziała.  
Pojemniki przyjmują tylko kulki w swoim kolorze.

Parametry energetyczne kulek:  
Czerwona kulka ma o 3 jednostki energii więcej niż zielona.  
Niebieska kulka ma o 1 jednostkę energii więcej niż czerwona.  
Trzy zielone kulki mają o 2 jednostki energii mniej niż jedna niebieska.”
\end{quote}

\subsubsection{Kulki}

W scenie zaprojektowano trzy typy kulek: czerwone, zielone oraz niebieskie. 
Zostały one zrealizowane za pomocą trzech blueprintów aktorów: \texttt{BR}, \texttt{BB} oraz \texttt{BG}, gdzie pierwsza litera jest skrótem od słowa „Ball”, a druga od pierwszej litery koloru.

Każdy obiekt kulki składa się z:
\begin{itemize}
    \item komponentu \texttt{StaticMesh} w postaci sfery,
    \item komponentu \texttt{Box Collision},
    \item tagu \texttt{Ball},
    \item tagu odpowiadającego kolorowi kulki (\texttt{Green}, \texttt{Blue}, \texttt{Red}).
\end{itemize}

Kulki są obiektami fizycznymi, które gracz może podnosić, przenosić oraz umieszczać w kontenerach.

\subsubsection{Kontenery}

W scenie zaimplementowano trzy kontenery w postaci obiektów typu Blueprint Actor:
\texttt{BP\_Container\_Red}, \texttt{BP\_Container\_Blue} oraz \texttt{BP\_Container\_Green}.

Ściany każdego kontenera składają się z czterech komponentów typu \texttt{StaticMesh} z materiałem szklanym, dna wykonanego z komponentu \texttt{StaticMesh} w odpowiednim kolorze oraz komponentu \texttt{Box Collision}.

Kontenery przyjmują oraz przekazują do żarówki wartości energetyczne kulek odpowiadającego im koloru. 
Mechanizm ten został zrealizowany w taki sposób, że w momencie wejścia obiektu w obszar \texttt{Box Collision} kontener sprawdza, czy obiekt posiada tag \texttt{Ball} oraz tag odpowiadający kolorowi kontenera. 
Jeżeli warunki są spełnione, kontener dodaje wartość energetyczną kulki do swojej łącznej wartości, która domyślnie wynosi 0. 
W przeciwnym przypadku nie jest wykonywana żadna akcja.

Jeżeli kulka opuszcza obszar kontenera, jej wartość energetyczna zostaje odjęta od sumy. 
Aktualne wartości energetyczne kontenerów są na bieżąco przekazywane do obiektu \texttt{BP\_Lamp}.

\subsubsection{Żarówka}

Żarówka została zrealizowana jako blueprint aktora \texttt{BP\_Lamp}. 
Obiekt składa się z komponentów:
\begin{itemize}
    \item \texttt{StaticMesh},
    \item \texttt{TextRender},
    \item \texttt{PointLight}.
\end{itemize}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/Lamp1.png}
    \caption{Wygląd pokoju z kulkami}
    \label{fig:Lamp}
\end{figure}
\subsection{Zakończenie zadania}
Komponent \texttt{TextRender} wyświetla wartość energii, którą gracz musi osiągnąć. 
Wartość ta jest generowana losowo przy każdym uruchomieniu gry z przedziału od 18 do 51.

W obiekcie \texttt{BP\_Lamp} zaimplementowano funkcję \texttt{ApplyTotal}, która porównuje sumę wartości energetycznych kulek przekazywanych przez kontenery z wygenerowaną wartością docelową. 
W przypadku zgodności wartości żarówka zmienia kolor, zapala się, a zadanie zostaje zaliczone. 
W przeciwnym przypadku lampa pozostaje wyłączona.

\section{Zadanie 13 – Stereometria (Jan Walczak)}
\label{sec:stereometria_praktyka}
\subsection{Problemy i różnice w realizacji zadania w praktyce}
Zadanie nie odbiega za bardzo od wcześniej opracowanego opisu teoretycznego. Zmieniono ilość wyświetlanych
brył geometrycznych. Według opisu graczowi miała być przedstawiana tylko jedna bryła. W praktyce takie zadanie byłoby
bardzo krótkie. Zdefiniowano więc pulę złożoną z 5 brył:
\begin{enumerate}
    \item kuli,
    \item stożka,
    \item walca,
    \item sześcianu,
    \item ostrosłupa prawidłowego czworokątnego.
\end{enumerate}
Do każdej z wymienionych brył wybrano 3 pytania. Dotyczą one kolejno:
\begin{itemize}
    \item rodzaju bryły,
    \item wzoru na obliczenie powierzchni bryły,
    \item wzoru na obliczenie objętości bryły.
\end{itemize}
Gracz musi odpowiedzieć na wszystkie 3 pytania prawidłowo. Jeśli się pomyli, ze zbioru wybierana jest inna bryła.
Inna niż ta, o którą pytano go przed chwilą. W ten sposób uniknięto sytuacji, w której gracz odpowiadałby losowo i
przechodził zadanie metodą eliminacji.

\subsection{Implementacja zadania}
W zadaniu został zaimplementowany jeden główny kontroler \verb|SelectorControler|. Jego zadaniem jest inicjalizacja gry,
zarządzanie przebiegiem gry, wyświetlanie tekstu i wybór odpowiednich pytań, wyświetlanych graczowi. Zawiera on dwustronną
referencję do obiektu \verb|Stereometry| oraz dwustronną referencję do trzech obiektów \verb|Button| (takich, jak te
opisane w podrozdziałach \ref{sec:planimetria_praktyka} i \ref{sec:stereometria_praktyka}). Zawiera także predefiniowany
zbiór pytań, dotyczących każdej z brył, reprezentowany przez mapę typu \textit{pytanie:poprawna odpowiedź}.

Obiekt \verb|Stereometry| odpowiada za poprawne wyświetlanie brył. Zawiera 5 obiektów 
typu siatki statycznej, które wyświetla w świecie gry, wybierając bryłę odpowiadającą aktualnie zadawanemu pytaniu. 
Jest też odpowiedzialny  za pseudolosowy mechanizm wyboru brył. Przed wyświetleniem obiekt \verb|Stereometry| w sposób pseudolosowy 
obraca bryłę, zmienia jej rozmiar, oraz położenie w świecie gry. W tym przypadku nie było potrzeby implementowania mechanizmu
powiadomień, ponieważ rodzaj komunikatów wysyłanych pomiędzy obiektami \verb|Stereometry| i \verb|SelectorControler| jest
prosty i zawsze jednakowy (żądanie wyświetlenia nowej bryły). Dodatkowo, obiekt \verb|Stereometry| zawiera referencję
do kontrolera tylko dlatego, że jego inicjalizacja jest długa (prawdopodobnie przez wczytywanie siatek statycznych brył,
z nałożoną teksturą odbijającą światło). Musi więc powiadomić kontroler główny, że zakończył swoją inicjalizację, aby ten
mógł zacząć wykonywać na nim operacje, przez wywołanie odpowiednich funkcji.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.7\textwidth]{images/stereometria_UML.png}
    \caption{Diagram UML zawierający najważniejsze elementy kontrolerów dla zadania 13 -- stereometria.}
    \label{stereometria:uml}
\end{figure}

\subsection{Przebieg zadania}
Kontroler inicjalizuje podrzędne mu obiekty i rozpoczyna grę. W sposób pseudolosowy wybierana jest jedna z 5 predefiniowanych
brył, poprzez wywołanie odpowiedniej funkcji obiektu \verb|Stereometry|. Gracz ma do wyboru 3 przyciski, które 
zawierają odpowiedzi \textit{A, B} lub \textit{C}. Pytania są wyświetlane sekwencyjnie -- najpierw zadawane jest pytanie 
o typ bryły, potem o wzór na obliczenie jej pola powierzchni, a na końcu o wzór na obliczanie jej objętości.

Jeśli gracz pomyli się podczas udzielania odpowiedzi, kontroler ponownie wywoła funkcję odpowiedzialną za wybór
kolejnej bryły. W takim przypadku może się ona pojawić ponownie w zadaniu, ale nie od razu po udzieleniu błędnej
odpowiedzi. Jeśli gracz odpowie na wszystkie 3 pytania prawidłowo, bryła zostaje uznana za zaliczoną i jest usuwana
z puli dostępnych do wylosowania brył. Gra kończy się kiedy gracz poprawnie odpowie na pytania dotyczące 3 różnych brył.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.7\textwidth]{images/stereometria_FLOW.png}
    \caption{Diagram przepływu dla zadania 13 -- stereometria}
    \label{stereometria:flow}
\end{figure}