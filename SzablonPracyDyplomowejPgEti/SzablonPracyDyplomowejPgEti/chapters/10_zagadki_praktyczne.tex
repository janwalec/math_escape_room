\chapter{Implementacja zagadek}
\label{chap:development}

\section{Zadanie 1 – wzory skróconego mnożenia (Autor)}
a
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Zadanie 2 – Planimetria (Jan Walczak)}
\label{sec:planimetria_praktyka}

\subsection{Problemy i różnice w realizacji zadania w praktyce}
Podczas implementacji zadania, zgodnie z teorią opisaną w podrozdziale \ref{subsec:planimetria_teoria},
wystąpiło kilka problemów. Przede wszystkim zauważono, że odpowiedzi są zero-jedynkowe.
Przykładowo: uczeń ma do uzupełniania relację typu \glqq każdy kwadrat ... prostokątem\grqq. Jeśli 
odpowie niepoprawnie, tj. zaznaczy odpowiedź \glqq nie jest\grqq, a zostanie od razu zapytany ponownie, o tę
samą relację, to od razu wyklucza jedną z odpowiedzi. Tym samym zadanie zatraca swoją wartość edukacyjną
-- uczeń może rozwiązać całe zadanie, stosując jedynie metodę eliminacji.

Rozwiązanie tego problemu, które zostało zaimplementowane, to zdefiniowanie puli takich relacji i po udzieleniu
przez ucznia odpowiedzi, każdorazowe losowanie relacji innej niż ta poprzednia.
W ten sposób uniemożliwia się uczniowi stosowanie zasady eliminacji i wymusza na nim prawidłowe podejście.

Kolejnym problemem była prezentacja zadania. Zwykła tabela, którą uczeń miałby uzupełniać, mogłaby wydać mu się
mało ciekawa. Tym samym postanowiono wizualnie usprawnić zagadkę. Na środku zostały umieszczone dwa przyciski:
\begin{itemize}
    \item każdy
    \item nie każdy
\end{itemize}
Uczeń zostaje poinstruowany, że po obu ścianach pokoju zostaną wyświetlone różne figury geometryczne. Po lewej stronie,
patrząc od przycisków -- figury oznaczone kolorem czerwonym, po prawej stronie -- figury oznaczone kolorem zielonym.
Liczba figur jest stała, każdorazowo typ wyświetlanych figur jest wybierany z określonej puli i wyświetlany w pseudolosowej 
konfiguracji -- losowane jest ich położenie, obrót oraz rozmiar. Zadaniem ucznia jest uzupełnianie kolejnych relacji poprzez
wybieranie odpowiednich przycisków. Relacja, wyświetlana na ścianie pokoju, przedstawia się jako:
\glqq każdy typ figury, narysowany kolorem czerwonym, jest równocześnie typem figury oznaczonym kolorem zielonym\grqq.
Dodatkowo, tekst jest odpowiednio pokolorowany, tak aby uczeń nie miał wątpliwości, że chodzi o typ figury, wyświetlanej tymże kolorem
na ścianach.

\subsection{Implementacja struktury danych przechowującej relację}
Na początku pracy należało zdefiniować strukturę, przechowującą relacje, czyli pytania, na które uczeń
będzie odpowiadał. Relacja taka została zawiera następujące pola:

\begin{itemize}
    \item \verb|Every| -- wartość logiczna
    \item \verb|FigureA| -- ciąg tekstowy, reprezentujący pierwszą figurę w relacji
    \item \verb|FigureB| -- ciąg tekstowy, reprezentujący drugą figurę w relacji
\end{itemize}

Wartość zmiennej \verb|Every| odpowiada na pytanie, \glqq czy każda figura typu pierwszego (\verb|FigureA|) jest równocześnie
figurą typu drugiego (\verb|FigureB|)?\grqq. Struktura zawiera również funkcję słownikową, czyli taką, która tłumaczy wartości
tekstowe na liczbowe.

\subsection{Implementacja kontrolerów}
Aby zarządzać zagadką została zaimplementowana seria kontrolerów i menedżerów.
\begin{itemize}
    \item \verb|ControlerFigures| (główny kontroler)
    \item \verb|FiguresTextManager|
    \item \verb|WallFigures|
\end{itemize}

\verb|WallFigures| to najprostszy z kontrolerów, wykonuje polecenia głównego kontrolera. Jego zadaniem jest 
wyświetlanie żądanych figur i ich losowe ustawianie w świecie gry (obracanie, skalowanie, rozmieszczanie). W projekcie występują
jego dwie instancje: kontroler lewy i prawy. Odpowiadają za odpowiednie ściany, na których wyświetlane są figury.

\verb|FiguresTextManager| jest odpowiedzialny za zarządzanie tekstem wyświetlanym na ekranie. Wykonuje polecenia
głównego kontrolera. Jego zadaniem jest odpowiednie wyświetlanie i kolorowanie tekstu.

\verb|ControlerFigures|, czyli kontroler główny, jest najważniejszym elementem zagadki. Zawiera referencję do pozostałych
kontrolerów, zarządza obiektami, wyświetlanymi na scenie i kontroluje przebieg zadania. Dodatkowo, zawiera dwustronną
referencję do przycisków (\verb|Button|), które wysyłają do niego powiadomienia o tym, że zostały naciśnięte.
Kontroler zawiera też predefiniowaną tablicę relacji typów figur opisanych wcześniej.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.7\textwidth]{images/planimetreia_UML.png}
    \caption{Diagram UML zawierający najważniejsze elementy kontrolerów dla zadania 2 -- planimetria.}
    \label{planimetria:uml}
\end{figure}

\FloatBarrier

\subsection{Przebieg zadania}
Główny kontroler jest odpowiedzialny za inicjalizację zadania. Uruchamia on funkcję 
\verb|InitBlueprint|, odpowiedzialną za wywołanie odpowiednich funkcji podrzędnych 
elementów, takich jak: ustawienie tekstu, inicjalizacja ścian i przycisków.

Kontroler oczekuje na otrzymanie powiadomienia, od przycisku, odpowiedzialnego za uruchomienie gry.
Kiedy otrzyma powiadomienie, przesłane mu za pośrednictwem odpowiedniej funkcji, uruchamia grę, tj. wywołuje
funkcje podrzędnych komponentów, ustawiając im odpowiednią widoczność w świecie gry.

Z predefiniowanej tablicy relacji zostaje wybrana jedna, która zostaje wyświetlona graczowi
Główny kontroler czeka na powiadomienia od przycisków. Kiedy zostaje powiadomiony o tym, że jeden z nich, został naciśnięty
sprawdza poprawność odpowiedzi. Jeśli odpowiedź jest poprawna, usuwa relację z tablicy i  losuje kolejną. Jeśli nie jest poprawna,
losuje kolejną relację, do wyświetlenia graczowi i nie zalicza punktu. Gra kończy się po poprawnym uzupełnieniu przez gracza wszystkich relacji.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.7\textwidth]{images/planimetria_FLOW.png}
    \caption{Diagram przepływu dla zadania 2 -- planimetria}
    \label{planimetria:flow}
\end{figure}

\FloatBarrier
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Zadanie 3 – Nierówności (Autor)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Zadanie 4 – Funkcje (Autor)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Zadanie 5 – Geometria analityczna (Autor)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Zadanie 6 – Kombinatoryka (Autor)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Zadanie 7 – Liczby rzeczywiste i działania na zbiorach liczbowych 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\texorpdfstring{\\}{ } (Jan Walczak)}
\label{sec:rzeczywiste_praktyka}
\subsection{Problemy i różnice w realizacji zadania w praktyce}
\label{subsec:rzeczywiste_problemy}
Podczas implementacji zadania, zgodnie z teorią opisaną w podrozdziale \ref{subsec:liczby_rzeczywiste},
należało wprowadzić, względem niej, kilka poprawek. Pierwotny mechanizm zakładał, że zamek, umieszczony na skrzyni, będzie
wyposażony w pola, w które uczeń wpisywałby odpowiednie cyfry -- liczby elementów danego podzbioru. W praktyce
okazało się to niemożliwe. Maksymalna liczba jednocyfrowa to 9, tym samym zadanie jest ograniczone do wyświetlania maksymalnie 9 liczb
rzeczywistych w pokoju. 

Zamysł został zmieniony i zamiast kłódki postanowiono umieścić elektroniczny zamek, wyposażony w klawiaturę.
W ten sposób otrzymano możliwość umieszczenia więcej niż 9 liczb w pokoju. Uczeń staje również przed dodatkowym wyzwaniem -- 
wywnioskować kolejność wpisywanych liczb zgodnie z podpowiedzią, umieszczoną na ścianie (patrz rysunek \ref{rzeczywiste:screen}).

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.7\textwidth]{images/liczby_rzeczywiste_screen.png}
    \caption{Zrzut ekranu -- skrzynia z zamkiem oraz podpowiedź na ścianie dla zadania 7.}
    \label{rzeczywiste:screen}
\end{figure}
\FloatBarrier

Zmienione zostały również liczby, które są rozmieszczone w pokoju. Aktualnie pojawiają się liczby: 
\textit{15; π; 4,5; √2; ¼; -3; 1; -7; ⅓ ; 9} Tym samym kombinacja prezentuje się następująco (kolejność zgodna z podpowiedzią 
na rysunku \ref{rzeczywiste:screen})
\begin{itemize}
    \item \textit{N} (naturalne): \textit{15; 1; 9} – 3 liczby,
    \item \textit{C} (całkowite):  \textit{15; 1; 9; -3; -7} – 5 liczb,
    \item \textit{R} (rzeczywiste): wszystkie liczby – 10 liczb,
    \item \textit{W} (wymierne): \textit{15; 1; 9; -3; -7; 4,5; ¼; ⅓} – 8 liczb,
    \item \textit{NW} (niewymierne): \textit{π; √2} – 2 liczby.
\end{itemize}
Tym samym kombinacja do otwarcia sejfu to \textit{351082}.

Ostatnią rzeczą, która została zmieniona jest koncepcja drugiej części zadania. Mechanizm obracania bloczków został uznany za niepotrzebny,
ponieważ wybrane relacje są jednoznaczne -- są czytane zawsze od lewej do prawej strony. Niepoprawny obrót bloczka od razu sugeruje
błędną odpowiedź.

Spośród wszystkich relacji zostały wybrane dwie:
\begin{itemize}
    \item $N \subset Z \subset R$,
    \item $NW \cap W = \varnothing$,
\end{itemize}
Zostały one wybrane przez swoją charakterystykę. Pierwsza z nich pokazuje, jak kolejne zbiory zawierają się w sobie nawzajem,
a druga pokazuje rozłączność zbiorów liczb wymiernych i niewymiernych.
Gracz ma do dyspozycji 6 bloczków:
\begin{itemize}
    \item dwa bloczki z symbolem $\subset$,
    \item dwa bloczki z symbolem $\varnothing$,
    \item dwa bloczki z symbolem $\cap$
\end{itemize}
Bloczki mają mu służyć do uzupełnienia dwóch relacji wymienionych wyżej. Po ułożeniu relacji, poprawnie bądź nie, bloczki pozostają
do dyspozycji gracza.

\subsection{Implementacja zadania}

Został zaimplementowany jeden, główny kontroler \verb|RealNumbersController|. Zarządza on przebiegiem zadania, położeniem elementów na scenie 
oraz wyświetlaniem tekstu. Zawiera odpowiednie referencje do komponentów i odpowiada za poprawną inicjalizację.

Komponent \verb|Element| jest bloczkiem z odpowiednim symbolem relacji, \verb|Sejf| jest skrzynią, która przetrzymuje bloczki,
a \verb|WallQuestion| to płaska tablica (ścianka), na której wyświetlane są pytania w drugiej części zadania.

\verb|Sejf| zawiera jednostronną referencję do głównego kontrolera. Kontroler może zostać przez niego powiadomiony, że gracz
poprawnie wpisał kod. W ten sposób kontroler może sterować dalszym przebiegiem zadania. \verb|WallQuestion| zawiera dwustronną referencję
do głównego kontrolera. Mechanizm powiadomień działa tutaj podobnie ale kontroler może odpowiadać, na otrzymywane powiadomienia, poprzez
wywoływanie odpowiednich funkcji.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.7\textwidth]{images/real_UML.png}
    \caption{Diagram UML zawierający najważniejsze elementy dla zadania 7 -- liczby rzeczywiste i działania na zbiorach liczbowych.}
    \label{rzeczywiste:UML}
\end{figure}
\FloatBarrier

\subsection{Przebieg zadania}
Zadanie rozpoczyna się od pierwszej części -- wpisania kodu do skrzyni. Kontroler inicjalizuje komponenty, a  na ścianach i na skrzyni 
zostają wyświetlone liczby opisane w \ref{subsec:rzeczywiste_problemy}. Gracz powinien policzyć ile liczb, z jakiego zbioru, jest 
wyświetlanych w pokoju i poprawnie wpisać kod. W doborze kolejności wpisywanych liczb pomaga mu podpowiedź, umieszczona na ścianie.
Po poprawnym wpisaniu kodu, kontroler główny zostaje powiadomiony, przez instancję skrzyni, że zadanie może przejść do następnego etapu.
Drzwi się otwierają a kontroler inicjalizuje 6 bloczków, opisanych w \ref{subsec:rzeczywiste_problemy} i ściankę z pytaniami \verb|WallQuestion|.
Zapisuje pozycję oraz obrót bloczków w świecie gry, tak aby możliwy był powrót do stanu początkowego.

Ścianka wykrywa kolizję z bloczkami, które gracz na niej umieszcza. W momencie kiedy zostaje uzupełniona w całości, tj. bloczki wypełniają 
miejsca na odpowiedzi, powiadamia kontroler o rozwiązaniu zadania. Kontroler decyduje czy odpowiedź gracza jest poprawna. W przypadku gdy 
jest, to przesyła do \verb|WallQuestion| powiadomienie o zmianie pytania na kolejne i zalicza punkt. Jeżeli odpowiedź nie jest poprawna, to
również powiadamia o tym ściankę, ale nie zalicza punktu. W obu przypadkach bloczki wracają na wcześniej zapisaną pozycję.
W zależności, od poprawności udzielonej odpowiedzi, ścianka rozświetla się kolorem zielonym lub czerwonym, tak żeby gracz miał pewność, że udzielona
odpowiedź jest poprawna. Podczas sprawdzania stanu ścianki, tj. ustawienie bloczków przez gracza, pytanie zostaje zablokowane, a gracz nie może
modyfikować swojej odpowiedzi (dokładać lub zabierać bloczków).

Kiedy gracz odpowie na oba pytania poprawnie, poziom zostaje uznany za zaliczony.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{images/real_FLOW.png}
    \caption{Diagram przepływu dla zadania 7 -- liczby rzeczywiste i działania na zbiorach liczbowych.}
    \label{rzeczywiste:FLOW}
\end{figure}
\FloatBarrier

\subsection{Implementacja mechanizmu uzupełniania ścianki}
Ścianka, czyli \verb|WallQuestion|, wykrywa kolizję z bloczkami, czyli \verb|Element|, w dwóch miejscach, w których będą one docelowo
umieszczone. Kiedy gracz przytrzyma bloczek, nad jednym z dwóch wskazanych miejsc, uruchamiana jest odpowiednia funkcja \verb|StartCollision()|. 
W zależności, od tego gdzie został umieszczony bloczek, sprawdzany jest aktualny stan ścianki -- czy w danym miejscu gracz umieścił już bloczek.
Jeśli tak, to ścianka nie pozwoli mu umieścić w tym miejscu kolejnego bloczka, dopóki nie wyjmie poprzedniego. Dzieje się tak za sprawą dwóch
zmiennych wartości logicznych: \verb|ActorHovered| i \verb|ActorLockedIn|. Oznaczają one kolejno: stan, w którym gracz trzyma bloczek nad ścianką
i stan, w którym gracz umieścił bloczek na ściance. W przypadku gdy \verb|ActorLockedIn| jest ustawione na wartość \verb|0|, to zapisywana
jest referencja bloczku, który został właśnie umieszczony. 

Dodatkowo informacja o tym, że gracz puścił bloczek, czyli zamierza go umieścić w danym miejscu, jest odpowiednio zapisywana w instancji bloczka.
Kiedy bloczek znajduje się w ręce gracza otrzymuje sygnaturę \verb|held|. Kiedy gracz go puści, sygnatura jest odbierana. Wyżej wymienione wartości
logiczne są ustawiane dopiero wtedy, kiedy sygnatura najpierw istniała (w instancji bloczka), a potem została z niej usunięta.

W przypadku, gdy gracz chce usunąć bloczek ze ścianki, sytuacja jest analogiczna. Tym razem jednak, sprawdzamy czy bloczek, który zabiera gracz,
jest tym znajdującym się na ściance, poprzez porównanie referencji. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Zadanie 8 – Znaki funkcji trygonometrycznych (Autor)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Zadanie 9 – Ciągi liczbowe (Jan Walczak)}
\label{sec:ciągi_praktyka}
\subsection{Problemy i różnice w realizacji zadania w praktyce}
W przeciwieństwie do zadań opisanych w podrozdziałach \ref{sec:planimetria_praktyka} i \ref{sec:rzeczywiste_praktyka} w tym zadaniu nie 
pojawiło się  dużo rozbieżności między teorią, a praktyczną implementacją.

Miejsce, w którym wprowadzono modyfikację, to warunki zakończenia gry. Zadanie, przez swój projekt, stawia bardziej na szybką analizę, niż
na długie zastanawianie się nad odpowiedzią. Jest bezpośrednio inspirowane prawdziwą grą, w której największą wartością, wyróżniającą gracza, jest jego
czas reakcji. Z tego powodu zdecydowano się na usunięcie limitu czasowego. Gra przyspiesza liniowo, razem z postępem, tj. liczbą zestrzelonych przez
gracza kaczek.

Dodatkowo zwiększono liczbę żyć, tj. możliwości na pomyłkę gracza, do 4 zamiast 3. Jest to spowodowane wprowadzeniem dodatkowej mechaniki gry -- jeśli
kaczka wyleci poza zasięg gracza (za ścianę), gracz traci życie. Gra kończy się jedynie w momencie utraty wszystkich żyć -- co musi nastąpić, ponieważ
prędkość kaczek będzie rosła tak długo, jak toczy się rozgrywka.

\subsection{Implementacja pistoletu laserowego}
Implementacja pistoletu laserowego była kluczowym punktem, potrzebnym do stworzenia całego poziomu. 

Aby poprawnie zaimplementować taki laser potrzebne są trzy wartości:
\begin{itemize}
    \item punkt początkowy, od którego zaczynamy rysowanie lasera,
    \item punkt końcowy, do którego laser będzie rysowany,
    \item wektor kierunkowy, według którego laser będzie rysowany.
\end{itemize}

Za punkt początkowy został obrany koniec ręki gracza, tj. kontrolera, którym steruje. Z ustawienia kontrolera w świecie gry można również 
wyznaczyć wektor kierunkowy. Należy pobrać z kontrolera wartość tego wektora, przy użyciu systemowej funkcji Unreal Engine \verb|Get Forward Vector|. 
Należy zapisać ten wektor, razem z punktem początkowym. Obliczenie punktu końcowego jest nieco trudniejsze. Polega na początkowym pomnożeniu 
wektora kierunkowego przez inny wektor, o dużych wartościach poszczególnych współrzędnych, a następnym dodaniu wyniku tego działania do 
współrzędnych punktu początkowego. W projekcie zastosowano wektor $(1000,0; 1000,0; 1000,0)$. Tak obliczony punkt należało chwilowo zapisać jako punkt końcowy.

Następnie, przy użyciu systemowej funkcji \verb|Line Trace by Channel|, należało wyznaczyć punkt, w którym linia, poprowadzona od punktu
początkowego do końcowego, przecina się ze światem przedstawionym w grze. Funkcja ta zwraca wynik w postaci wartości typu struktury \verb|Hit Result|, 
który można rozbić na składowe i pozyskać z niego \verb|Impact Point|, czyli rzeczywisty punkt końcowy oraz \verb|Distance|, czyli 
wartość zmiennoprzecinkową, reprezentującą długość wyznaczonej linii.

Dzięki obliczonym wartościom można narysować laser, przebiegający od kontrolera gracza, do pierwszego napotkanego obiektu w grze. W tym celu kontroler ma
na stałe przypisany obiekt \verb|Static Mesh|, z siatką statyczną w kształcie cylindra, który jest rozciągany zgodnie z obliczonymi wartościami. Nałożony jest
na niego materiał, emitujący czerwone światło. Na końcu rozciągniętej siatki statycznej, umieszczona jest niewidzialna kulka, z włączonym systemem kolizji. 
Dzięki niej można wykrywać, w jaki komponent na scenie, aktualnie celuje gracz.

Na rysunku \ref{fig:sequence_laser} widać, że laser faktycznie wykrywa otoczenie, w które celuje gracz i zmienia odpowiednio swoją długość. Zmianie
ulega również kierunek, w którym celuje gracz.
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.7\textwidth]{images/sequence_laser.png}
    \caption{Porównanie rysowania lasera w przypadku kontaktu z przykładowym elementem otoczenia i ścianą.}
    \label{fig:sequence_laser}
\end{figure}

\subsection{Implementacja zadania}

Zaimplementowany został jeden, główny kontroler \verb|SequenceControler|.
Jego zadaniem jest inicjalizacja gry, zarządzanie przebiegiem gry, wyświetlanie tekstu i zarządzanie instancjami kaczek. Kontroler, wybiera pseudolosowo,
jeden z trzech dostępnych wzorów, na kolejny wyraz ciągu arytmetycznego, według którego będą obliczane kolejne elementy. Dostępne są wzory:
\begin{itemize}
    \item $a_n = 3n + 4$
    \item $a_n = 2n + 3$
    \item $a_n = 5n + 7$
\end{itemize}

Komponent \verb|Duck| implementuje funkcjonalności związane ze sterowaniem pojedynczej kaczki. Zawiera dwustronną referencję, do obiektu głównego kontrolera
i przesyła powiadomienia, kiedy zostanie zestrzelony przez gracza, przy użyciu pistoletu laserowego. W instancji kaczki zapisywana jest pozycja początkowa, numer,
który aktualnie jest na niej wyświetlany i wartość zmiennoprzecinkowa, czyli droga, którą pokona kaczka, w każdej jednostce czasu w grze.

Gracz zostaje również zapoznany z zasadami działania gry. Kiedy jest gotowy do rozpoczęcia gry, naciska przycisk, podobny do tego opisanego w podrozdziale 
\ref{sec:planimetria_praktyka}. Przycisk działa na tej samej zasadzie i również posiada dwustronną referencję do instancji kontrolera.

W zagadce występują jeszcze dwa komponenty: \verb|HitWall| i \verb|Life|. Główny kontroler zawiera tablicę referencji do 4 
instancji obiektów \verb|Life|. Reprezentują ilość pozostałych żyć gracza i nie pełnią w logice działania programu żadnej 
istotnej roli, poza tą wizualną. \verb|HitWall| jest obiektem niewidocznym, znajdującym się poza zasięgiem gracza. Lecące 
kaczki będą wykrywać ten obiekt i sygnalizować to głównemu kontrolerowi zderzenie tak, jakby zostały trafione. Jeżeli kaczka uderzy w 
ten komponent, wyśle specjalny typ powiadomienia, mówiący o tym, że graczowi nie udało się jej zestrzelić. Jeśli kaczka 
zawierała poprawny wyraz ciągu to kontroler odczyta to jako błąd gracza i odejmie mu jedno życie. W takim przypadku, jeżeli 
gracz ma jeszcze pozostałe życia, wyświetli się kolejny wyraz ciągu, a kaczki zaczną lecieć od początku.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.7\textwidth]{images/sequence_UML.png}
    \caption{Diagram UML zawierający najważniejsze elementy dla zadania 9 -- Ciągi liczbowe.}
    \label{fig:sequence_UML}
\end{figure}

\subsection{Przebieg zadania}
Zadanie rozpoczyna się od inicjalizacji komponentów przez główny kontroler.  Początkowo graczowi zostaje
wyświetlona instrukcja do zadania. Kiedy gracz będzie gotowy może rozpocząć grę naciskając przycisk \glqq
Start\grqq. Kontroler zostaje w takiej sytuacji powiadomiony, przez instancję przycisku i rozpoczyna grę. W sposób 
pseudolosowy zostaje wybrany jeden z trzech wzorów na kolejny \textit{n-ty} wyraz ciągu arytmetycznego. Kontroler ustawia również
poprawny wyraz ciągu, początkowo $n = 0$, na jednej z trzech kaczek. Pozostałe kaczki otrzymują wyrazy, większe
lub mniejsze od poprawnego wyrazu, również w sposób pseudolosowy. Dzieje się to wedle zasady, że wybrane wyrazy mogą być
odległe jedynie o 2 jednostki na osi współrzędnych, od poprawnego wyrazu ($a_n \pm 2$).

Kaczki pokonują stałą jednostkę odległości, w każdej jednostce, czasu wykonywania się programu, wyrażoną za pomocą
liczby zmiennoprzecinkowej. Jednostka ta jest tym większa, im większy jest aktualny numer wyrazu ciągu
arytmetycznego. Oznacza to, że będą przyspieszać razem z przebiegiem gry. Do tak obliczonej, stałej wartości,
dodawana jest pseudolosowa wartość zmiennoprzecinkowa wybrana pseudolosowo z przedziału $\left[0,5; 0,7\right] $. 

Kaczki poruszają się od lewej do prawej strony ekranu, aż do zderzenia się z instancją obiektu \verb |HitWall|. 
Kaczki mogą zostać zestrzelone przez gracza, zanim zderzą się z wyżej wymienionym obiektem. 
W obu przypadkach, do kontrolera wysyłane jest powiadomienie odpowiedniego rodzaju: 
kaczka została zestrzelona lub kaczka  zderzyła się z obiektem \verb|HitWall|. 
W powiadomieniu przekazana jest również liczba całkowita, która znajdowała się na danej kaczce. 

Kontroler po otrzymaniu w powiadomieniu liczby oraz informacji, czy dana kaczka została zestrzelona, 
podejmuje decyzję:
\begin{enumerate}
  \item Jeśli liczba jest poprawnym wyrazem ciągu -- zalicza punkt i ustawia ponownie kaczki. Zwiększa też numer wyrazu ciągu.
  \item Jeśli liczba nie jest poprawna -- odejmuje jedno życie, ale nie ustawia ponownie kaczek.
  \item Jeśli kaczka, przechowująca poprawny wyraz ciągu, uderzy w obiekt \verb|HitWall| (wyleci poza 
  zasięg gracza) -- odejmuje jedno życie i ponownie ustawia kaczki. Zwiększa też numer wyrazu ciągu.
\end{enumerate}
Ponowne ustawienie kaczeek polega na obliczeniu kolejnego wyrazu ciągu arytmetyczngo, ustawieniu go na 
jednej z nich, ustawieniu dwóm pozostałym kaczkom błędnego wyrazu oraz na cofnięciu ich do stanu 
początkowego. Gra kończy się w momencie, gdy gracz straci wszystkie 4 życia.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{images/sequence_FLOW.png}
    \caption{Diagram przepływu dla zadania 9 -- Ciągi liczbowe }
    \label{sequence:flow}
\end{figure}

\section{Zadanie 10 – Prawdopodobieństwo (Autor)}
\section{Zadanie 11 – Optymalizacja i rachunek różniczkowy (Autor)}
\section{Zadanie 12 – Układy równań (Autor)}

\section{Zadanie 13 – Stereometria (Jan Walczak)}
\label{sec:stereometria_praktyka}
\subsection{Problemy i różnice w realizacji zadania w praktyce}
Zadanie nie odbiega za bardzo od wcześniej opracowanego opisu teoretycznego. Zmieniono ilość wyświetlanych
brył geometrycznych. Według opisu graczowi miała być przedstawiana tylko jedna bryła. W praktyce takie zadanie byłoby
bardzo krótkie. Zdefiniowano więc pulę złożoną z 5 brył:
\begin{enumerate}
    \item kuli,
    \item stożka,
    \item walca,
    \item sześcianu,
    \item ostrosłupa prawidłowego czworokątnego.
\end{enumerate}
Do każdej z wymienionych brył wybrano 3 pytania. Dotyczą one kolejno:
\begin{itemize}
    \item rodzaju bryły,
    \item wzoru na obliczenie powierzchni bryły,
    \item wzoru na obliczenie objętości bryły.
\end{itemize}
Gracz musi odpowiedzieć na wszystkie 3 pytania prawidłowo. Jeśli się pomyli, ze zbioru wybierana jest inna bryła,
inna niż ta, o którą pytano go przed chwilą. W ten sposób uniknięto sytuacji, w której gracz odpowiadałby losowo i
przechodził zadanie metodą eliminacji.

\subsection{Implementacja zadania}
W zadaniu został zaimplementowany jeden główny kontroler \verb|SelectorControler|. Jego zadaniem jest inicjalizacja gry,
zarządzanie przebiegiem gry, wyświetlanie tekstu i wybór odpowiednich pytań, wyświetlanych graczowi. Zawiera on dwustronną
referencję do obiektu \verb|Stereometry| oraz dwustronną referencję do trzech obiektów \verb|Button| (takich, jak te
opisane w podrozdziałach \ref{sec:planimetria_praktyka} i \ref{sec:stereometria_praktyka}). Zawiera także predefiniowany
zbiór pytań, dotyczących każdej z brył, reprezentowany przez mapę typu \textit{pytanie:poprawna odpowiedź}.

Obiekt \verb|Stereometry| odpowiada za poprawne wyświetlanie brył. Zawiera 5 obiektów 
typu siatki statycznej, które wyświetla w świecie gry, wybierając bryłę odpowiadającą aktualnie zadawanemu pytaniu. 
Jest też odpowiedzialny  za pseudolosowy mechanizm wyboru brył. Przed wyświetleniem obiekt \verb|Stereometry|, w sposób pseudolosowy, 
obraca bryłę, zmienia jej rozmiar, oraz położenie w świecie gry. W tym przypadku nie było potrzeby implementowania mechanizmu
powiadomień, ponieważ rodzaj komunikatów wysyłanych pomiędzy obiektami \verb|Stereometry| i \verb|SelectorControler| jest
prosty i zawsze jednakowy (żądanie wyświetlenia nowej bryły). Dodatkowo, obiekt \verb|Stereometry| zawiera referencję
do kontrolera tylko dlatego, że jego inicjalizacja jest długa (prawdopodobnie przez wczytywanie siatek statycznych brył,
z nałożoną teksturą odbijającą światło). Musi więc powiadomić kontroler główny, że zakończył swoją inicjalizację, aby ten
mógł zacząć wykonywać na nim operacje, przez wywołanie odpowiednich funkcji.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.7\textwidth]{images/stereometria_UML.png}
    \caption{Diagram UML zawierający najważniejsze elementy kontrolerów dla zadania 13 -- stereometria.}
    \label{stereometria:uml}
\end{figure}

\subsection{Przebieg zadania}
Kontroler inicjalizuje podrzędne mu obiekty i rozpoczyna grę. W sposób pseudolosowy, wybierana jest jedna z 5 predefiniowanych
brył, poprzez wywołanie odpowiedniej funkcji obiektu \verb|Stereometry|. Gracz ma do wyboru 3 przyciski, które 
zawierają odpowiedzi \textit{A, B} lub \textit{C}. Pytania są wyświetlane sekwencyjnie -- najpierw zadawane jest pytanie 
o typ bryły, potem o wzór na obliczenie jej pola powierzchni, a na końcu o wzór na obliczanie jej objętości.

Jeśli gracz pomyli się, podczas udzielania odpowiedzi, kontroler ponownie wywoła funkcję odpowiedzialną za wybór
kolejnej bryły. W takim przypadku może się ona pojawić ponownie w zadaniu, ale nie od razu po udzieleniu błędnej
odpowiedzi. Jeśli gracz odpowie na wszystkie 3 pytania prawidłowo, bryła zostaje uznana za zaliczoną i jest usuwana
z puli dostępnych do wylosowania brył. Gra kończy się kiedy gracz poprawnie odpowie na pytania dotyczące 3 różnych brył.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.7\textwidth]{images/stereometria_FLOW.png}
    \caption{Diagram przepływu dla zadania 13 -- stereometria}
    \label{stereometria:flow}
\end{figure}