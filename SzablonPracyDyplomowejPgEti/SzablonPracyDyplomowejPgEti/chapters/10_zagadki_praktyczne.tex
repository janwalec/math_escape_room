\chapter{Implementacja zagadek}
\label{chap:development}

\section{Zadanie 1 – wzory skróconego mnożenia (Autor)}
a
\section{Zadanie 2 – Planimetria (Jan Walczak)}
\label{sec:planimetria_praktyka}

\subsection{Problemy i różnice w realizacji zadania w praktyce}
Podczas implementacji zadania, zgodnie z teorią opisaną w podrozdziale \ref{subsec:planimetria_teoria}
napotkałem się z kilkoma problemami. Przede wszystkim zauważyłem, że odpowiedzi są zero--jedynkowe.
Przykładowo: uczeń ma do uzupełniania relację typu \glqq każdy kwadrat ... prostokątem\grqq. Jeśli 
odpowie niepoprawnie tj. zaznaczy odpowiedź \glqq nie jest\grqq, a zostanie od razu zapytany ponownie o tę
samą relację, to od razu wyklucza jedną z odpowiedzi. Tym samym zadanie zatraca swoją wartość edukacyjną
-- uczeń może rozwiązać całe zadanie stosując jedynie metodę eliminacji.

Rozwiązanie tego problemu, które zostało zaimplementowane, to zdefiniowanie puli takich relacji i po udzieleniu
przez ucznia odpowiedzi, każdorazowe losowanie relacji innej niż ta poprzednia.
W ten sposób uniemożliwia się uczniowi stosowania zasady eliminacji i wymusza na nim prawidłowe podejście.

Kolejnym problemem była prezentacja zadania. Zwykła tabela, którą uczeń miałby uzupełniać mogłaby wydać mu się
mało ciekawa. Tym samym postanowiłem wizualnie usprawnić zagadkę. Na środku zostały umieszczone dwa przyciski:
\begin{itemize}
    \item każdy
    \item nie każdy
\end{itemize}
Uczeń zostaje poinstruowany, że po obu ścianach pokoju zostaną wyświetlone różne figury geometryczne. Po lewej stronie,
patrząc od przycisków -- figury oznaczone kolorem czerwonym, po prawej stronie -- figury oznaczone kolorem zielonym.
Liczba figur jest stała, każdorazowo typ wyświetlanych figur jest wybierany z określonej puli i wyświetlany w pseudolosowej 
konfiguracji -- losowane jest ich położenie, obrót oraz rozmiar. Zadaniem ucznia jest uzupełnianie kolejnych relacji poprzez
wybieranie odpowiednich przycisków. Relacja wyświetlana na ścianie pokoju przedstawia się jako:
\glqq każdy typ figury, narysowany kolorem czerwonym, jest równocześnie typem figury oznaczonym kolorem zielonym\grqq.
Dodatkowo, tekst jest odpowiednio pokolorowany, tak aby uczeń nie miał wątpliwości, że chodzi o typ figury, wyświetlane tymże kolorem
na ścianach.

\subsection{Implementacja struktury danych przechowującej relację}
Na początku pracy należało zdefiniować strukturę, przechowującą relację, czyli innymi słowami, pytanie na które uczeń
będzie odpowiadał. Relacja taka została zdefiniowana jako aktor. Zawiera pola:

\begin{itemize}
    \item \verb|Every| -- wartość logiczna
    \item \verb|FigureA| -- ciąg tekstowy, reprezentujący pierwszą figurę w relacji
    \item \verb|FigureB| -- ciąg tekstowy, reprezentujący drugą figurę w relacji
\end{itemize}

Wartość zmiennej \verb|Every| odpowiada na pytanie, czy każda figura typu pierwszego (\verb|FigureA|) jest równocześnie
figurą typu drugiego (\verb|FigureB|). Struktura zawierała również funkcję słownikową, czyli taką, która tłumaczy wartości
tekstowe na liczbowe.

\subsection{Implementacja kontrolerów}
Aby zarządzać zagadką została zaimplementowana seria kontrolerów i menadżerów.
\begin{itemize}
    \item \verb|ControlerFigures| (główny kontroler)
    \item \verb|FiguresTextManager|
    \item \verb|WallFigures|
\end{itemize}

\verb|WallFigures| to najprostszy z kontrolerów. Wykonuje polecenia głównego kontrolera. Jego zadaniem jest 
wyświetlanie żądanych figur i ich losowe ustawianie (obracanie, skalowanie, rozmieszczanie). W projekcie występują
jego dwie instancje: kontroler lewy i prawy. Odpowiadają za odpowiednie ściany, na których wyświetlane są figury.

\verb|FiguresTextManager| jest odpowiedzialny za zarządzanie tekstem wyświetlanym na ekranie. Wykonuje polecenia
głównego kontrolera. Jego zadaniem jest odpowiednie wyświetlanie i kolorowanie tekstu.

\verb|ControlerFigures| czyli kontroler główny jest najważniejszym elementem zagadki. Zawiera referencję do pozostałych
kontrolerów, zarządza obiektami wyświetlanymi na scenie i kontroluje przebieg zadania. Dodatkowo zawiera dwustronną
referencję z instancjami przycisków \verb|Button|, które wysyłają do niego powiadomienia o tym, że zostały naciśnięte.
Kontroler zawiera też predefiniowaną tablicę relacji typów figur opisanych wcześniej.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.7\textwidth]{images/planimetreia_UML.png}
    \caption{Diagram UML zawierający najważniejsze elementy kontrolerów dla zadania 2 -- planimetria.}
    \label{planimetria:uml}
\end{figure}

\FloatBarrier

\subsection{Przebieg zadania}
Główny kontroler jest odpowiedzialny za inicjalizację zadania. Uruchamia on funkcję 
\verb|InitBlueprint|, odpowiedzialną za wywołanie odpowiednich funkcji, z podrzędnych 
elementów, takich jak: ustawienie tekstu, inicjalizacja ścian i przycisków. Ustawia także początkowe wartości zmiennych dla zadania.

Kontroler oczekuje na otrzymanie powiadomienia od przycisku odpowiedzialnego za uruchomienie gry.
Kiedy otrzyma dane powiadomienie, za pośrednictwem odpowiedniej funkcji, uruchamia grę tj. wywołuje
funkcje podrzędnych komponentów ustawiając im odpowiednią widoczność na scenie w grze.

Z predefiniowanej tablicy relacji zostaje wybrana jedna, która zostaje wyświetlona graczowi za pośrednictwem
wywołania odpowiednich funkcji.
Główny kontroler czeka na informacje od przycisków. Kiedy zostaje powiadomiony o tym, że jeden z nich, został naciśnięty
sprawdza poprawność odpowiedzi. Jeśli odpowiedź jest poprawna, usuwa relację z tablicy i  losuje kolejną. Jeśli nie jest poprawna,
losuje kolejną relację do wyświetlenia graczowi i nie zalicza punktu. Gra kończy się po poprawnym uzupełnieniu wszystkich relacji.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.7\textwidth]{images/planimetria_FLOW.png}
    \caption{Diagram przepływu dla zadania 2 -- planimetria}
    \label{planimetria:flow}
\end{figure}

\FloatBarrier

\section{Zadanie 3 – Nierówności (Autor)}
\section{Zadanie 4 – Funkcje (Autor)}
\section{Zadanie 5 – Geometria analityczna (Autor)}
\section{Zadanie 6 – Kombinatoryka (Autor)}
\section{Zadanie 7 – Liczby rzeczywiste i działania na zbiorach liczbowych 
\texorpdfstring{\\}{ } (Jan Walczak)}
\label{sec:rzeczywiste_praktyka}
\subsection{Problemy i różnice w realizacji zadania w praktyce}
\label{subsec:rzeczywiste_problemy}
Podczas implementacji zadania, zgodnie z teorią opisaną w podrozdziale \ref{subsec:liczby_rzeczywiste}
musiałem wprowadzić, względem niej, kilka poprawek. Pierwotny mechanizm zakładał, że zamek, umieszczony na skrzyni, będzie
wyposażony w pola na umieszczenie odpowiednich cyfr -- liczby elementów danego podzbioru znajdujących się na niej. W praktyce
okazało się to niemożliwe. Maksymalna liczba jednocyfrowa to 9, tym samym zadanie jest ograniczone do wyświetlania maksymalnie 9 liczb
rzeczywistych w pokoju. 

Postanowiłem zmienić zamysł i zamiast kłódki umieścić skrzynię z elektronicznym zamkiem i wyposażyć go w klawiaturę.
W ten sposób dostajemy możliwość umieszczenia więcej niż 9 liczb w pokoju. Uczeń staje równiez przed dodatkowym zadaniem -- 
wywnioskować kolejność wpisywanych liczb zgodnie z podpowiedzią, umieszczoną na ścianie (patrz rysnuek \ref{rzeczywiste:screen}).

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.7\textwidth]{images/liczby_rzeczywiste_screen.png}
    \caption{Zrzut ekranu -- skrzynia z zamkiem oraz podpowiedź na ścianie dla zadania 7.}
    \label{rzeczywiste:screen}
\end{figure}
\FloatBarrier

Zmienione zostały również liczby, które są rozmieszczone w pokoju. Aktualnie pojawiają się liczby: 
\textit{15; π; 4,5; √2; ¼; -3; 1; -7; ⅓ ; 9} Tym samym kombinacja prezentuje się następująco (kolejność zgodna z podpowiedzią 
na rysunku \ref{rzeczywiste:screen})
\begin{itemize}
    \item \textit{N} (naturalne): \textit{15; 1; 9} – 3 liczby,
    \item \textit{C} (całkowite):  \textit{15; 1; 9; -3; -7} – 5 liczb,
    \item \textit{R} (rzeczywiste): wszystkie liczby – 10 liczb,
    \item \textit{W} (wymierne): \textit{15; 1; 9; -3; -7; 4,5; ¼; ⅓} – 8 liczb,
    \item \textit{NW} (niewymierne): \textit{π; √2} – 2 liczby.
\end{itemize}

Tym samym kombinacja do otwarcia sejfu to \textit{351082}.

Ostatnią rzeczą, która została zmieniona jest koncepcja drugiej części zadania. Niepotrzebny jest mechanizm obracania bloczków,
ponieważ wybrane relacje są jednoznaczne -- są czytane zawsze od lewej do prawej strony. Niepoprawny obrót bloczka od razu sugeruje
błędną odpowiedź -- tym samym jest to mechanizm bezcelowy.

Spośród wszystkich relacji zostały wybrane dwie:
\begin{itemize}
    \item $N \subset Z \subset R$,
    \item $NW \cap W = \varnothing$,
\end{itemize}
Zostały one wybrane przez swoją charakterystykę. Pierwsza z nich pokazuje, jak kolejne zbiory zawierają się w sobie nazwajem,
a druga pokazuje rozłączność zbiorów liczb wymiernych i niewymiernych.
Gracz ma do dyspozycji 6 bloczków:
\begin{itemize}
    \item dwa bloczki z symbolem $\subset$,
    \item dwa bloczki z symbolem $\varnothing$,
    \item dwa bloczki z symbolem $\cap$
\end{itemize}
Mają mu posłużyć do uzupełnienia dwóch relacji wymienionych wcześniej. Po ułożeniu relacji poprawnie bądź nie bloczki pozostają
do dyspozycji gracza.

\subsection{Implementacja kontrolera}

W przeciwieństwie do zadania drugiego, opisanego w \ref{sec:planimetria_praktyka}, został zaimplementowany jedynie jeden, główny 
kontroler \verb|RealNumbersController|. Zarządza on przebiegiem zadania, położeniem elementów na scenie oraz wyświetlaniem tekstu.
Zawiera odpowiednie referencje do komponentów i odpowiada za poprawną inicjalizację.

Komponent \verb|Element| jest bloczkiem z odpowiednim symbolem relacji, \verb|Sejf| jest skrzynią, która przetrzymuje bloczki,
a \verb|WallQuestion| to płaska tablica (ścianka), na której wyświetlane są pytania w drugiej części zadania.

\verb|Sejf| posiada jednostronną referencję do głównego kontrolera. Kontroler może zostać przez niego powiadomiony, że gracz
poprawnie wpisał kod, tak aby kontroler mógł sterować dalszym przebiegiem zadania. \verb|WallQuestion| zawiera dwustronną referencję
do głównego kontrolera. Mechanizm powiadomień działa tutaj podobnie ale kontroler może odpowiadać na otrzymywane powiadomienia poprzez
wywoływanie odpowiednich funkcji.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.7\textwidth]{images/real_UML.png}
    \caption{Diagram UML zawierający najważniejsze elementy dla zadania 7 -- liczby rzeczywiste i działania na zbiorach liczbowych.}
    \label{rzeczywiste:UML}
\end{figure}
\FloatBarrier

\subsection{Przebieg zadania}
Zadanie rozpoczyna się od pierwszej części -- wpisania kodu do skrzyni. Kontroler inicjalizuje komponenty, a  na ścianach i na skrzyni 
zostają wyświetlone liczby opisane w \ref{subsec:rzeczywiste_problemy}. Gracz powinien policzyć ile liczb i z jakiego zbioru jest 
wyświetlanych w pokoju i poprawnie wpisać kod, według podpowiedzi znajdującej się na ścianie.
Po poprawnym wpisaniu kodu, kontroler główny zostaje powiadomiony przez instancję skrzyni, że zadanie może przejść do następnego etapu.
Drzwi się otwierają a kontroler inicjalizuje 6 bloczków, opisanych w \ref{subsec:rzeczywiste_problemy} i ściankę z pytaniami \verb|WallQuestion|.
Zapisuje pozycję oraz obrót bloczków w świecie, tak aby możliwy był powrót do stanu początkowego, między udzielanymi odpowiedziami.

Ścianka wykrywa kolizję z bloczkami, które gracz na niej umieszcza. W momencie kiedy zostaje uzupełniona w całości tj. bloczki wypełniają 
miejsca na odpowiedzi, to powiadamia kontroler o rozwiązaniu zadania. Kontroler decyduje czy odpowiedź gracza jest poprawna. W przypadku gdy 
jest, to przesyła do \verb|WallQuestion| powiadomienie o zmianie pytania na kolejne i zalicza punkt. Jeżeli odpowiedź nie jest poprawna, to
również powiadamia o tym ściankę, ale nie zalicza punktu. W obu przypadkach bloczki wracają na wcześniej zapisaną pozycję.
W zależności od poprawności udzielonej odpowiedzi ścianka rozświetla się kolorem zielonym lub czerwonym, tak żeby gracz miał pewność, że udzielił
dobrej odpowiedzi. Podczas sprawdzania stan ścianki tj. ustawienie bloczków i pytanie zostaje zablokowany i gracz nie może go modifykować (dokładać
lub zabierać bloczków).

Kiedy gracz odpowie na oba pytania poprawnie poziom zostaje uznany za zaliczony.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{images/real_FLOW.png}
    \caption{Diagram przepływu dla zadania 7 -- liczby rzeczywiste i działania na zbiorach liczbowych.}
    \label{rzeczywiste:FLOW}
\end{figure}
\FloatBarrier

\subsection{Implementacja mechanizmu uzupełniania ścianki}
Ścianka, czyli \verb|WallQuestion|, wykrywa kolizję z bloczkami, czyli \verb|Element| w dwóch miejscach, w których będą one docelowo
umieszczone. Kiedy gracz przytrzyma bloczek nad jednym z miejsc uruchamiana jest odpowiednia funkcja \verb|StartCollision()|. W zależności,
od tego gdzie został umieszczony bloczek, sprawdzany jest aktualny stan ścianki -- czy w tym miejscu gracz zdążył już umieścić bloczek.
Jeśli tak, to ścianka nie pozwoli mu umieścić w tym miejscu kolejnego bloczka, dopóki nie wyjmie poprzedniego. Dzieje się tak za sprawą dwóch
zmiennych wartości logicznych: \verb|ActorHovered| i \verb|ActorLockedIn|. Oznaczają one kolejno: stan, w którym gracz trzyma bloczek nad ścianką
i stan, w którym gracz umieścił bloczek na ściance. W przypadku gdy \verb|ActorLockedIn| jest ustawione na wartość \verb|0|, to zapisywana
jest referencja bloczku, który został właśnie umieszczony. 

Dodatkowo informacja o tym, że gracz puścił bloczek, czyli zamierza go umieścić w danym miejscu, jest odpowiednio zapisywana w bloczku.
Kiedy bloczek znajduje się w ręce gracza otrzymuje sygnaturę \verb|held|. Kiedy go puści, sygnatura jest odbierana. Wyżej wymienione wartości
logiczne są ustawiane dopiero wtedy, kiedy sygnatura najpierw istniała w instancji bloczka, a potem została z niej usunięta.

W przypadku, gdy gracz chce usunąć bloczek ze ścianki sytuacja jest analogiczna. Tym razem jednak, sprawdzamy czy bloczek, który zabiera gracz,
jest tym znajdującym się na ściance, poprzez porównanie referencji. 

\section{Zadanie 8 – Znaki funkcji trygonometrycznych (Autor)}
\section{Zadanie 9 – Ciągi liczbowe (Jan Walczak)}
\label{sec:ciągi_praktyka}
\subsection{Problemy i różnice w realizacji zadania w praktyce}
W przeciwieństwie do zadań opisanych w podroździałach \ref{sec:planimetria_praktyka} i \ref{sec:rzeczywiste_praktyka} w tym zadaniu nie pojawiło się 
dużo rozbieżności między teorią, a praktyczną implementacją.

Miejsce, w którym wprowadziłem modyfikację, to warunki zakończenia gry. Zadanie, przez swój projekt, stawia bardziej na szybką analizę, niż
na długie zastanawianie się nad odpowiedzią. Jest bezpośrednio inspirowane prawdziwą grą, w której największą wartością, wyróżniającą gracza, jest jego
czas reakcji. Z tego powodu zdecydowałem się na usunięcie limitu czasowego. Gra przyspiesza liniowo, razem z postępem tj. liczbą zestrzelonych przez
gracza kaczek.

Dodatkowo zwiększyłem liczbę żyć tj. możliwości na pomyłkę gracza do 4 zamiast 3. Jest to spowodowane wprowadzeniem dodatkowej mechaniki gry -- jeśli
kaczka wyleci poza zasięg gracza (za ścianę) gracz traci życie. Gra kończy się jedynie w momencie utraty wszsyskich żyć -- co musi nastąpić, ponieważ
prędkość kaczek będzie rosła tak długo, jak długo toczy się rozgrywka.

\subsection{Implementacja pistoletu laserowego}
Implementacja pistoletu lasterowego była kluczowym punktem, potrzebnym do stworzenia całego poziomu. 

Aby poprawnie zaimplementować taki laser potrzebne są w sumie trzy wartości:
\begin{itemize}
    \item punkt początkowy, od którego zaczynamy rysowanie lasera
    \item punkt końcowy, do którego laser będzie rysowany
    \item wektor kierunkowy, według którego laser będzie rysowany
\end{itemize}

Za punkt początkowy został obrany koniec ręki gracza tj. kontrolera którym steruje. Kolejno, z ustawienia gracza można wyznaczyć wektor kierunkowy.
Wystarczy pobrać z kontrolera jego wartość przy użyciu systemowej funkcji Unreal Engine \verb|Get Forward Vector|. Należało go zapisać,
razem z punktem początkowym. Obliczenie punktu końcowego jest nieco trudniejsze. Polega na początkowym pomnożeniu wektora kierunkowego przez inny wektor,
o dużych wartościach poszczególnych współrzędnych, a następnym dodaniu wyniku tego działania do współrzędnych punktu początkowego. 
W projekcie zastosowano wektor $(1000,0; 1000,0; 1000,0)$. Tak obliczony punkt należało chwilowo zapisać jako punkt końcowy.

Następnie, przy użyciu systemowej funkcji \verb|Line Trace by Channel|, należało wyznaczyć punkt, w którym linia, poprowadzona od punktu
początkowego do końcowego, przecina się ze światem przedstawionym w symulacji. Funkcja ta zwraca wynik w postaci wartości typu struktury \verb|Hit Result|, 
który można rozbić na składowe i pozyskać z niego \verb|Impact Point|, czyli rzeczywisty punkt końcowy oraz \verb|Distance|, c
zyli wartość zmiennoprzecinkową reprezentującą długość wyznaczonej linii.

Z obliczonymi wartościami można narysować laser, przebiegający od kontrolera gracza, do pierwszego napotkanego obiektu w grze. W tym celu kontroler ma
na stałe przypisany obiekt \verb|Static Mesh| z siatką statyczną w kształcie cylindra, który jest rozciągany według obliczonych wartości. Nałożony jest
na niego materiał emitujący czerwone światło. Na końcu, rozciągniętej siatki statycznej, umieszczona jest niewidzialna kulka, z włączonym systemem kolizji. 
Dzięki niej można wykrywać, w jaki komponent na scenie, aktualnie celuje gracz.

Na rysunku \ref{fig:sequence_laser} widać, że laser faktycznie wykrywa otoczenie, w które celuje gracz i zmienia odpowiednio swoją długość. Zmianie
ulega również kierunek, w którym celuje gracz.
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.7\textwidth]{images/sequence_laser.png}
    \caption{Porównanie rysowania lasera w przypadku kontaktu z przykładowym elementem otoczenia i ścianą.}
    \label{fig:sequence_laser}
\end{figure}

\subsection{Implementacja kontrolera}

Podobnie jak w zadaniu opisanym w podroździale \ref{sec:rzeczywiste_praktyka} zaimplementowany został jeden, główny kontroler \verb|SequenceControler|.
Jego zadaniem jest inicjalizacja gry, zarządzenie przebiegiem gry, wyświetlanie tekstu i zarządzanie instancjami kaczek. Kontroler wybiera pseudolosowo
jeden z trzech dostępnych wzorów na kolejny wyraz ciągu arytmetycznego, według którego będzie wybierał kolejne elementy:
\begin{itemize}
    \item $a_n = 3n + 4$
    \item $a_n = 2n + 3$
    \item $a_n = 5n + 7$
\end{itemize}

Komponent \verb|Duck| implementuje funkcjonalności związane ze sterowaniem pojedynczej kaczki. Zawiera dwustronną referencję do obiektu głównego kontrolera
i przesyła powiadomienia, kiedy zostanie zestrzelony przez gracza, przy użyciu pistoletu laserowego. W jej instancji zapisywana jest pozycja początkowa, numer,
który aktualnie jest na niej wyświetlany i wartość zmiennoprzecinkowa, czyli droga, którą pokona kaczka w każdej klatce wykonywania się programu.

Gracz zostaje również zapoznany z zasadami działania gry. Kiedy jest gotowy, do rozpoczęcia gry, naciska przycisk podobny do tego opisanego w podroździale
\ref{sec:planimetria_praktyka}. Działa na tej samej zasadzie i również posiada dwustronną referencję do instancji kontrolera.

W zagadce występują jeszcze dwa komponenty: \verb|HitWall| i \verb|Life|. Główny kontroler zawiera tablicę referencji do 4 
instancji obiektów \verb|Life|. Reprezentują ilość pozostałych żyć gracza i nie pełnią w logice działania programu żadnej 
istotnej roli, poza tą wizualną. \verb|HitWall| jest obiektem niewidocznym, znajdującym się poza zasięgiem gracza. Lecące 
kaczki będą wykrywać ten obiekt, 
po przeleceniu przez ścianę i sygnalizować to głównemu kontrolerowi tak, jakby zostały trafione. Jeżeli kaczka uderzy w 
ten komponent to wyśle specjalny typ powiadomienia, mówiący o tym, że graczowi nie udało się jej zestrzelić. Jeśli kaczka 
zawierała poprawny wyraz ciągu to kontroler oznaczyto jako błąd i odejmie graczowi jedno życie. W takim przypadku, jeżeli 
gracz ma jeszcze pozostałe życia, wyświetli się kolejny wyraz ciągu, a kaczki zaczną lecieć od początku.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.7\textwidth]{images/sequence_UML.png}
    \caption{Diagram UML zawierający najważniejsze elementy dla zadania 9 -- Ciągi liczbowe.}
    \label{fig:sequence_UML}
\end{figure}

\subsection{Przebieg zadania}
Zadanie rozpoczyna się od inicjalizacji komponentów przez główny kontroler.  Początkowo graczowi zostaje
wyświetlona instrukcja do zadania. Kiedy gracz będzie gotowy może rozpocząć grę naciskając przycisk \glqq
Start\grqq. Kontroler zostaje w takiej sytuacji powiadomiony przez instancję przycisku i rozpoczyna grę. W sposób 
pseudolsowy zostaje wybrany jeden z trzech wzorów na kolejny \textit{n-ty} wyraz ciągu arytmetycznego. Ustawia również
poprawny wyraz ciągu, początkowo $n = 0$, na jednej z trzech kaczek. Pozostałe kaczki otrzymują wyrazy, większe
lub mniejsze od poprawnego wyrazu, również w sposób pseudolosowy, biorąc pod uwagę to, że wybrane wyrazy mogą być
odległe jedynie o 2 jednostki na osi współrzędnych, od poprawnego wyrazu.  

Kaczki pokonują stałą jednostkę odległości w każdej jednostce czasu wykonywania się programu, wyrażoną za pomocą
liczby zmiennoprzecinkowej. Jednostka ta jest tym większa, im większy jest aktualny numer wyrazu ciągu
arytmetycznego. Oznacza to, że będą przyspieszać razem z przebiegiem gry. Do tak obliczonej, stałej wartości,
dodawana jest pseudolosowa wartość zmiennoprzecinkowa wybrana z przedziału $\left[0,5; 0,7\right] $. 

Kaczki poruszają się od lewej do prawej strony ekranu, aż do zderzenia się z instancją obiektu \verb HitWall|. Kaczki mogą zostać zestrzelone przez gracza, zanim zderzą się z wyżej wymienionym obiektem. W obu przypadkach, do kontrolera wysyłane jest powiadomienie odpowiedniego rodzaju: kaczka została zestrzelona lub kaczka  zderzyła się z obiektem \verb|HitWall|. W powiadomieniu przekazana jest również wartość stałoprzecinkowa, reprezentująca liczbę, która znajdowała sie na danej kaczce. 

Kontroler po otrzymaniu w powiadomieniu liczby oraz informacji, czy dana kaczka została zestrzelona, 
podejmuje decyzję:
\begin{enumerate}
  \item Jeśli liczba jest poprawnym wyrazem ciągu -- zalicza punkt i ustawia ponownie kaczki.
  \item Jeśli liczba nie jest poprawna -- odejmuje jedno życie, ale nie ustawia ponownie kaczek.
  \item Jeśli kaczka, przechowująca poprawny wyraz ciągu, uderzy w obiekt \verb|HitWall| (wyleci poza 
  zasięg gracza) -- odejmuje jedno życie i ponownie ustawia kaczki.
\end{enumerate}
Ponowne ustawienie kaczek polega na obliczeniu kolejnego wyrazu ciągu arytmetycznego, ustawieniu go na 
jednej z nich, ustawieniu dwóm pozostałym kaczkom błędnego wyrazu oraz na cofnięciu ich do stanu 
początkowego. Gra kończy się w momencie, gdy gracz straci wszystkie 4 życia.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{images/sequence_FLOW.png}
    \caption{Diagram przepływu dla zadania 9 -- Ciągi liczbowe }
    \label{sequence:flow}
\end{figure}

\section{Zadanie 10 – Prawdopodobieństwo (Autor)}
\section{Zadanie 11 – Optymalizacja i rachunek różniczkowy (Autor)}
\section{Zadanie 12 – Układy równań (Autor)}
\section{Zadanie 13 – Stereometria (Jan Walczak)}
